<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ã‚«ãƒ¡ãƒ©ï¼‹æ‰‹æãï¼‹ã‚ºãƒ¼ãƒ ï¼‹æ˜ åƒèª¿æ•´ï¼‹é™æ­¢ç”»ï¼å‹•ç”»ï¼TL</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="data:,">
  <style>
    html, body { margin:0; padding:0; height:100%; font-family:system-ui,-apple-system,BlinkMacSystemFont; background:#000; color:#fff;}
    #app{ display:flex; flex-direction:column; height:100vh;}
    header{
      padding:8px 12px; font-size:14px; background:rgba(0,0,0,0.7);
      display:flex; justify-content:space-between; align-items:center;
      z-index:5; position:relative;
    }
    #header-left{ display:flex; align-items:center; gap:6px; min-width:0;}
    header span.title{ font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:50vw;}
    #header-right{ display:flex; gap:8px; align-items:center;}

    #qr-button{
      width:32px; height:32px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(255,255,255,0.10); color:#fff;
      display:flex; align-items:center; justify-content:center;
      cursor:pointer; padding:0;
    }
    #qr-button svg{ width:18px; height:18px; display:block; }
    #qr-button:active{ transform:translateY(1px); }

    #qr-overlay{
      position:fixed; inset:0; background:rgba(0,0,0,0.85);
      display:none; align-items:center; justify-content:center; z-index:50;
    }
    #qr-overlay.open{ display:flex; }
    #qr-box{
      background:#fff; color:#000; width:100vw; height:100vh;
      border-radius:0; display:flex; flex-direction:column;
      align-items:center; justify-content:center; text-align:center;
      box-sizing:border-box; padding:16px;
    }
    #qr-box h2{ margin:0 0 8px; font-size:15px;}
    #qr-img{ width:min(80vw,80vh); height:min(80vw,80vh); display:block; margin:0 auto;}
    #qr-close{
      margin-top:8px; padding:6px 16px; border-radius:999px;
      border:none; background:#333; color:#fff; cursor:pointer; font-size:13px;
    }

    #header-palette{ display:flex; gap:6px; align-items:center; margin-right:4px;}
    .swatch-btn{
      position:relative;
      width:32px; height:32px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.55);
      background:rgba(0,0,0,0.4);
      padding:0; cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      box-shadow:0 0 0 1px rgba(0,0,0,0.35) inset;
    }
    .swatch-btn.active{ outline:2px solid rgba(125,211,252,0.95); outline-offset:2px;}
    .swatch-circle{ border-radius:50%; background:#fff; transition:width .15s ease,height .15s ease;}
    .swatch-pen{ position:absolute; font-size:14px; pointer-events:none; text-shadow:0 0 2px rgba(0,0,0,0.6);}

    .tool-toggle.active{ outline:2px solid rgba(125,211,252,0.95); outline-offset:2px;}

    #camera-wrapper{
      position:relative; flex:1; background:#000;
      overflow:hidden;
      touch-action:none;
    }
    #camera-inner{
      position:absolute; inset:0;
      transform-origin:0 0;
    }
    #video{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit:cover;
    }
    #draw-layer,#ui-layer{ position:absolute; inset:0;}
    #draw-layer{ z-index:2; }
    #ui-layer{ z-index:3; }
    #text-layer{ z-index:4; }
    #draw-layer{ touch-action:none;}
    #ui-layer{ pointer-events:none;}

    /* ãƒ†ã‚­ã‚¹ãƒˆDOMï¼ˆã‚ºãƒ¼ãƒ è¿½å¾“ã®ãŸã‚ cameraInnerå†…ï¼‰ */
    #text-layer{
      position:absolute; inset:0; z-index:3;
      pointer-events:none;
    }
    .text-box{
      position:absolute; min-width:24px; min-height:18px;
      pointer-events:auto;
      user-select:none;
      touch-action:none;
    }
    .text-content{
      white-space:pre;
      line-height:1.25;
      text-shadow:0 0 2px rgba(0,0,0,0.6);
    }
    .text-box.selected{
      outline:2px dashed rgba(125,211,252,0.95);
      outline-offset:2px;
    }
    .resize-handle{
      position:absolute; width:16px; height:16px;
      right:-10px; bottom:-10px;
      border-radius:4px;
      background:rgba(125,211,252,0.95);
      border:2px solid rgba(0,0,0,0.8);
      cursor:nwse-resize;
      display:none;
    }
    .text-box.selected .resize-handle{ display:block; }

    /* ç·¨é›†ã‚¨ãƒ‡ã‚£ã‚¿ã¯ cameraInnerå¤–ï¼ˆtransformå½±éŸ¿å›é¿ï¼‰ */
    #text-editor{
      position:absolute;
      z-index:100;
      display:none;
      pointer-events:auto;
      box-sizing:border-box;
    }
    #text-editor textarea{
      width:100%; height:100%;
      resize:none;
      box-sizing:border-box;
      border-radius:10px;
      border:2px solid rgba(125,211,252,0.95);
      background:rgba(0,0,0,0.55);
      color:#fff;
      padding:8px 10px;
      outline:none;
      box-shadow:0 8px 20px rgba(0,0,0,0.45);
    }

    #toolbar{
      position:fixed; left:0; right:0; bottom:8px;
      display:flex; flex-wrap:nowrap;
      justify-content:center; align-items:center;
      gap:6px; padding:6px 8px;
      border-radius:999px;
      background:rgba(0,0,0,0.75);
      backdrop-filter:blur(6px);
      z-index:20;
      max-width:100%;
      box-sizing:border-box;
    }
    .tool-btn{
      width:clamp(28px,7vw,40px);
      height:clamp(28px,7vw,40px);
      border-radius:50%;
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(255,255,255,0.06);
      color:#fff;
      font-size:clamp(14px,3vw,20px);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer; padding:0; flex:0 0 auto;
    }
    .tool-btn.small{
      width:clamp(26px,6.5vw,36px);
      height:clamp(26px,6.5vw,36px);
      font-size:clamp(13px,2.8vw,18px);
    }
    .tool-btn:disabled{ opacity:0.35; cursor:default;}
    .tool-group-sep{ width:4px; flex:0 0 auto;}
    .rec-timer{ font-size:11px; min-width:40px; text-align:center; color:#eee; flex:0 0 auto;}

    .floating-panel{
      position:fixed;
      background:rgba(0,0,0,0.8);
      padding:6px 8px;
      border-radius:10px;
      font-size:11px;
      color:#eee;
      z-index:25;
      max-width:320px;
      box-shadow:0 2px 8px rgba(0,0,0,0.6);
      display:none;
    }
    .floating-panel .panel-title{ font-weight:600; margin-bottom:4px; font-size:11px;}
    .floating-panel label{
      display:flex; align-items:center; gap:6px; margin-bottom:3px; white-space:nowrap;
    }
    .floating-panel input[type="number"]{ width:70px; font-size:11px;}
    .floating-panel input[type="color"]{ width:32px; height:18px; padding:0; border:none; background:transparent;}
    .floating-panel input[type="range"]{ width:130px;}
    .floating-panel select{ font-size:11px; max-width:200px;}
    .panel-row{ display:flex; gap:8px; align-items:center; margin-top:6px;}
    .panel-btn{
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(255,255,255,0.10);
      color:#fff;
      height:28px;
      padding:0 10px;
      cursor:pointer;
      font-size:12px;
    }
    #video-panel{ right:10px; bottom:84px; }

    #log-toggle,#btn-clear,#tool-eraser,#tool-shape,#btn-undo,#tool-text{
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(255,255,255,0.10);
      color:#fff;
      width:40px; height:40px;
      display:flex; align-items:center; justify-content:center;
      cursor:pointer; font-size:20px; padding:0;
    }
    #btn-undo:disabled{ opacity:0.35; cursor:default;}

    #btn-clear .eraser-icon{
      display:block; width:22px; height:14px;
      border-radius:3px;
      background:linear-gradient(to bottom,#f5c37a 0 45%,#f5c37a 45% 50%,#365e9a 50% 100%);
      box-shadow:0 0 0 1px rgba(0,0,0,0.25) inset, 0 1px 0 rgba(255,255,255,0.2);
      margin-top:2px;
    }

    #log-panel{
      position:fixed; left:10px; top:56px;
      width:260px; max-height:50vh;
      background:rgba(0,0,0,0.8);
      border-radius:8px; padding:6px;
      font-size:11px; color:#eee;
      box-shadow:0 2px 8px rgba(0,0,0,0.6);
      z-index:30; display:none;
    }
    #log-panel.open{ display:block;}
    #log{ max-height:40vh; overflow-y:auto; white-space:pre-line;}

    #zoom-hint{
      position:fixed; top:50%; left:50%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.7);
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      color:#fff;
      z-index:25;
      display:none;
      pointer-events:none;
    }
    #zoom-hint.visible{ display:block;}
  </style>
</head>
<body>
<div id="app">
  <header>
    <div id="header-left">
      <button id="qr-button" title="ã“ã®ã‚¢ãƒ—ãƒªã®QRã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤º" aria-label="QRã‚³ãƒ¼ãƒ‰">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="3" y="3" width="7" height="7" fill="none" stroke="currentColor" stroke-width="2"/>
          <rect x="5" y="5" width="3" height="3" fill="currentColor"/>
          <rect x="14" y="3" width="7" height="7" fill="none" stroke="currentColor" stroke-width="2"/>
          <rect x="16" y="5" width="3" height="3" fill="currentColor"/>
          <rect x="3" y="14" width="7" height="7" fill="none" stroke="currentColor" stroke-width="2"/>
          <rect x="5" y="16" width="3" height="3" fill="currentColor"/>
          <rect x="14" y="14" width="3" height="3" fill="currentColor"/>
          <rect x="18" y="14" width="3" height="3" fill="currentColor"/>
          <rect x="14" y="18" width="3" height="3" fill="currentColor"/>
        </svg>
      </button>
      <span class="title">ã‚«ãƒ¡ãƒ©ï¼‹æ‰‹æãï¼‹ã‚ºãƒ¼ãƒ ï¼‹æ˜ åƒèª¿æ•´ï¼‹é™æ­¢ç”»ï¼å‹•ç”»ï¼TLï¼ˆéŒ²ç”»ä¿®æ­£ç‰ˆï¼‹ä¸€æ™‚åœæ­¢ï¼‰</span>
    </div>
    <div id="header-right">
      <div id="header-palette" title="è‰²ãƒ‘ãƒ¬ãƒƒãƒˆï¼ˆç™½ãƒ»èµ¤ãƒ»æ°´è‰²ï¼‰">
        <button class="swatch-btn" data-pen-index="0" title="ãƒšãƒ³1"><span class="swatch-circle"></span><span class="swatch-pen">âœï¸</span></button>
        <button class="swatch-btn" data-pen-index="1" title="ãƒšãƒ³2"><span class="swatch-circle"></span><span class="swatch-pen">âœï¸</span></button>
        <button class="swatch-btn" data-pen-index="2" title="ãƒšãƒ³3"><span class="swatch-circle"></span><span class="swatch-pen">âœï¸</span></button>
      </div>
      <button id="tool-eraser" class="tool-toggle" title="æ¶ˆã—ã‚´ãƒ ï¼ˆæç·šã‚’å‰Šé™¤ï¼‰">ğŸ§½</button>
      <button id="tool-shape" class="tool-toggle" title="é¢ï¼ˆå››è§’ï¼‰">â–¡</button>
      <button id="tool-text" class="tool-toggle" title="ãƒ†ã‚­ã‚¹ãƒˆ">T</button>
      <button id="btn-undo" title="ä¸€ã¤æˆ»ã™ï¼ˆUndoï¼‰">â†¶</button>
      <button id="btn-clear" title="æ‰‹æãã‚¯ãƒªã‚¢"><span class="eraser-icon" aria-hidden="true"></span></button>
      <button id="log-toggle" title="ãƒ­ã‚°è¡¨ç¤ºï¼éè¡¨ç¤º">â„¹ï¸</button>
    </div>
  </header>

  <div id="camera-wrapper">
    <div id="camera-inner">
      <video id="video" autoplay playsinline></video>
      <canvas id="draw-layer"></canvas>
      <canvas id="ui-layer"></canvas>
      <div id="text-layer"></div>
    </div>
    <div id="text-editor"><textarea id="text-editor-ta"></textarea></div>
  </div>

  <div id="toolbar">
    <button id="btn-start-camera" class="tool-btn" title="ã‚«ãƒ¡ãƒ©é–‹å§‹">ğŸ¦</button>
    <button id="btn-freeze" class="tool-btn" title="ä¸€æ™‚åœæ­¢ï¼ˆãƒ•ãƒªãƒ¼ã‚ºï¼‰" disabled>â¸</button>

    <div class="tool-group-sep"></div>

    <button id="btn-shot" class="tool-btn" title="å†™çœŸæ’®å½±ï¼ˆPNGï¼‰" disabled>ğŸ“·</button>

    <div class="tool-group-sep"></div>

    <button id="btn-start-rec" class="tool-btn small" title="å‹•ç”»éŒ²ç”»é–‹å§‹" disabled>âº</button>
    <button id="btn-stop-rec" class="tool-btn small" title="å‹•ç”»éŒ²ç”»åœæ­¢" disabled>â¹</button>
    <span id="rec-timer" class="rec-timer">00:00</span>

    <div class="tool-group-sep"></div>

    <button id="btn-start-tl" class="tool-btn small" title="TLéŒ²ç”»é–‹å§‹" disabled>â±</button>
    <button id="btn-stop-tl" class="tool-btn small" title="TLéŒ²ç”»åœæ­¢" disabled>â¹</button>
    <span id="tl-timer" class="rec-timer">00:00</span>

    <div class="tool-group-sep"></div>

    <button id="btn-zoom-select" class="tool-btn small" title="ã‚ºãƒ¼ãƒ é ˜åŸŸã‚’é¸æŠ">ğŸ”</button>
    <button id="btn-zoom-reset" class="tool-btn small" title="ã‚ºãƒ¼ãƒ è§£é™¤">ğŸ”</button>

    <div class="tool-group-sep" style="width:8px;"></div>

    <button id="video-settings-toggle" class="tool-btn small" title="æ˜ åƒè¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º">ğŸš</button>
  </div>

  <div id="pen-config-0" class="floating-panel">
    <div class="panel-title">ãƒšãƒ³1</div>
    <label>è‰² <input type="color" id="pen-color-0" value="#ffffff"></label>
    <label>å¤ªã• <input type="number" id="pen-size-0" min="1" max="40" value="10"></label>
  </div>
  <div id="pen-config-1" class="floating-panel">
    <div class="panel-title">ãƒšãƒ³2</div>
    <label>è‰² <input type="color" id="pen-color-1" value="#ff0000"></label>
    <label>å¤ªã• <input type="number" id="pen-size-1" min="1" max="40" value="10"></label>
  </div>
  <div id="pen-config-2" class="floating-panel">
    <div class="panel-title">ãƒšãƒ³3</div>
    <label>è‰² <input type="color" id="pen-color-2" value="#7dd3fc"></label>
    <label>å¤ªã• <input type="number" id="pen-size-2" min="1" max="40" value="10"></label>
  </div>

  <div id="shape-config" class="floating-panel">
    <div class="panel-title">é¢ï¼ˆå››è§’ï¼‰</div>
    <label>è‰²ï¼ˆå¡—ã‚Šï¼†è¼ªéƒ­ å…±é€šï¼‰ <input type="color" id="shape-color" value="#ffffff"></label>
    <div style="color:#ccc;margin-top:4px;">â€»è¼ªéƒ­ç·šã¯å¸¸ã«10pxå›ºå®šã§ã™</div>
  </div>

  <div id="text-config" class="floating-panel">
    <div class="panel-title">ãƒ†ã‚­ã‚¹ãƒˆï¼ˆé¸æŠä¸­ï¼‰</div>
    <div style="color:#ccc;margin-bottom:6px;">
      ãƒ»Tãƒ„ãƒ¼ãƒ«ã§è¿½åŠ ï¼ˆã‚¯ãƒªãƒƒã‚¯ï¼‰<br>
      ãƒ»é¸æŠå¾Œï¼šãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹• / å³ä¸‹ãƒãƒ³ãƒ‰ãƒ«ã§æ‹¡å¤§ç¸®å° / ã“ã“ã§è‰²ãƒ»ãƒ•ã‚©ãƒ³ãƒˆãƒ»ã‚µã‚¤ã‚ºå¤‰æ›´<br>
      ãƒ»ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼ˆor ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ï¼‰ã§å†ç·¨é›†
    </div>
    <label>è‰² <input type="color" id="text-color" value="#ffffff"></label>
    <label>ã‚µã‚¤ã‚º <input type="number" id="text-size" min="8" max="200" value="36"></label>
    <label>ãƒ•ã‚©ãƒ³ãƒˆ
      <select id="text-font">
        <option value="system-ui, -apple-system, BlinkMacSystemFont">ã‚·ã‚¹ãƒ†ãƒ </option>
        <option value="sans-serif">sans-serif</option>
        <option value="serif">serif</option>
        <option value="monospace">monospace</option>
        <option value='"Hiragino Kaku Gothic ProN", "Yu Gothic", Meiryo, sans-serif'>æ—¥æœ¬èªã‚´ã‚·ãƒƒã‚¯</option>
        <option value='"Hiragino Mincho ProN", "Yu Mincho", serif'>æ—¥æœ¬èªæ˜æœ</option>
      </select>
    </label>
    <div class="panel-row">
      <button id="text-edit-btn" class="panel-btn" title="é¸æŠä¸­ãƒ†ã‚­ã‚¹ãƒˆã‚’ç·¨é›†">ç·¨é›†</button>
      <button id="text-delete-btn" class="panel-btn" title="é¸æŠä¸­ãƒ†ã‚­ã‚¹ãƒˆã‚’å‰Šé™¤">å‰Šé™¤</button>
    </div>
  </div>

  <div id="eraser-config" class="floating-panel">
    <div class="panel-title">æ¶ˆã—ã‚´ãƒ </div>
    <label>å¤ªã• <input type="number" id="eraser-size" min="5" max="80" value="30"></label>
  </div>

  <div id="video-panel" class="floating-panel">
    <div class="panel-title">éŒ²ç”»ï¼ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹è¨­å®š</div>
    <label>å‹•ç”»FPS <input type="number" id="video-fps" min="1" max="60" value="30"></label>
    <label>TL-FPS <input type="number" id="tl-fps" min="1" max="60" value="10"></label>
    <label>TLé–“éš”(ms) <input type="number" id="tl-interval" min="100" value="500"></label>

    <div class="panel-title" style="margin-top:4px;">æ˜ åƒè¨­å®š</div>
    <label>æ˜ã‚‹ã• <input id="brightness" type="range" min="0.2" max="2" step="0.01" value="1"></label>
    <label>ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ <input id="contrast" type="range" min="0.5" max="2" step="0.01" value="1"></label>
    <label>éœ²å‡º <input id="exposure" type="range" min="-2" max="2" step="0.1" value="0"></label>
    <label>è‰²æ¸©åº¦ <input id="color-temp" type="range" min="-1" max="1" step="0.1" value="0"></label>
    <label>ã‚·ãƒ£ãƒ¼ãƒ— <input id="sharpness" type="range" min="0" max="1" step="0.1" value="0"></label>
    <label><input id="line-boost" type="checkbox"> ç·šãƒ»æ–‡å­—ãã£ãã‚Š</label>
    <label><input id="noise-reduce" type="checkbox"> ãƒã‚¤ã‚ºè»½æ¸›ï¼ˆã‚ºãƒ¼ãƒ æ™‚ã®ã‚‚ã‚„ã‚‚ã‚„æŠ‘åˆ¶ï¼‰</label>

    <div class="panel-title" style="margin-top:4px;">è¡¨ç¤ºåè»¢</div>
    <label><input id="flip-h" type="checkbox" checked> å·¦å³åè»¢ï¼ˆãƒŸãƒ©ãƒ¼ï¼‰</label>
    <label><input id="flip-v" type="checkbox"> ä¸Šä¸‹åè»¢</label>

    <div class="panel-title" style="margin-top:4px;">ã‚«ãƒ¡ãƒ©é¸æŠ</div>
    <label>ã‚«ãƒ¡ãƒ© <select id="camera-select" disabled></select></label>

    <div class="panel-title" style="margin-top:4px;">éŸ³å£°</div>
    <label><input id="audio-enabled" type="checkbox"> å‹•ç”»ã«ãƒã‚¤ã‚¯éŸ³å£°ã‚’å…¥ã‚Œã‚‹</label>
    <div style="margin-top:3px;color:#ccc;">
      â€»ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯éŸ³å£°OFFã§ã™ã€‚<br>
      â€»ã€Œç·šãƒ»æ–‡å­—ãã£ãã‚Šã€ã€Œãƒã‚¤ã‚ºè»½æ¸›ã€ã¯ä¸»ã«ä¿å­˜ç”»åƒï¼éŒ²ç”»å‹•ç”»ã«åæ˜ ã•ã‚Œã¾ã™ã€‚<br>
      â€»ãƒ–ãƒ©ã‚¦ã‚¶éŒ²ç”»ã¯ WebM å½¢å¼ã§ä¿å­˜ã•ã‚Œã¾ã™ã€‚
    </div>
  </div>

  <div id="log-panel">
    <div style="font-weight:600;margin-bottom:4px;">ãƒ­ã‚°</div>
    <div id="log"></div>
    <div style="margin-top:4px;color:#ccc;">
      â€»ã‚ºãƒ¼ãƒ æ™‚ã¯ã€éŒ²ç”»ãƒ»TLã‚‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨åŒã˜è¦‹ãˆæ–¹ã§ä¿å­˜ã—ã¾ã™ã€‚<br>
      â€»ã€Œç·šãƒ»æ–‡å­—ãã£ãã‚Šã€ã¯ãƒãƒ¼ãƒˆã‚„ãƒ—ãƒªãƒ³ãƒˆæ’®å½±å‘ãã§ã™ã€‚
    </div>
  </div>

  <div id="zoom-hint">ã‚ºãƒ¼ãƒ ã—ãŸã„ç¯„å›²ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆæŒ‡ï¼ãƒšãƒ³ï¼ãƒã‚¦ã‚¹ï¼‰</div>

  <div id="qr-overlay">
    <div id="qr-box">
      <h2>ã“ã®ã‚¢ãƒ—ãƒªã®QRã‚³ãƒ¼ãƒ‰</h2>
      <img id="qr-img" alt="https://gensai-rika.github.io/camera/ ã®QRã‚³ãƒ¼ãƒ‰">
      <div style="font-size:11px;margin-top:4px;">ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</div>
      <button id="qr-close">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>

<script>
  const video = document.getElementById('video');
  const drawCanvas = document.getElementById('draw-layer');
  const uiCanvas = document.getElementById('ui-layer');
  const drawCtx = drawCanvas.getContext('2d', { willReadFrequently: true });
  const uiCtx = uiCanvas.getContext('2d');

  const cameraWrapper = document.getElementById('camera-wrapper');
  const cameraInner = document.getElementById('camera-inner');

  const textLayer = document.getElementById('text-layer');
  const textEditor = document.getElementById('text-editor');
  const textEditorTa = document.getElementById('text-editor-ta');

  const btnStartCamera = document.getElementById('btn-start-camera');
  const btnFreeze = document.getElementById('btn-freeze');

  const btnClear = document.getElementById('btn-clear');
  const btnUndo = document.getElementById('btn-undo');
  const btnShot = document.getElementById('btn-shot');
  const btnZoomSelect = document.getElementById('btn-zoom-select');
  const btnZoomReset = document.getElementById('btn-zoom-reset');
  const videoSettingsToggle = document.getElementById('video-settings-toggle');
  const videoPanel = document.getElementById('video-panel');

  // Recording controls
  const btnStartRec = document.getElementById('btn-start-rec');
  const btnStopRec = document.getElementById('btn-stop-rec');
  const recTimerEl = document.getElementById('rec-timer');

  const btnStartTl = document.getElementById('btn-start-tl');
  const btnStopTl = document.getElementById('btn-stop-tl');
  const tlTimerEl = document.getElementById('tl-timer');

  const videoFpsInput = document.getElementById('video-fps');
  const tlFpsInput = document.getElementById('tl-fps');
  const tlIntervalInput = document.getElementById('tl-interval');

  const swatchButtons = Array.from(document.querySelectorAll('.swatch-btn'));
  const toolEraserBtn = document.getElementById('tool-eraser');
  const toolShapeBtn = document.getElementById('tool-shape');
  const toolTextBtn  = document.getElementById('tool-text');

  const shapeConfigPanel = document.getElementById('shape-config');
  const shapeColorInput = document.getElementById('shape-color');

  const textConfigPanel = document.getElementById('text-config');
  const textColorInput = document.getElementById('text-color');
  const textSizeInput = document.getElementById('text-size');
  const textFontSelect = document.getElementById('text-font');
  const textEditBtn = document.getElementById('text-edit-btn');
  const textDeleteBtn = document.getElementById('text-delete-btn');

  const brightnessSlider = document.getElementById('brightness');
  const contrastSlider = document.getElementById('contrast');
  const exposureSlider = document.getElementById('exposure');
  const colorTempSlider = document.getElementById('color-temp');
  const sharpnessSlider = document.getElementById('sharpness');
  const lineBoostCheckbox = document.getElementById('line-boost');
  const noiseReduceCheckbox = document.getElementById('noise-reduce');
  const flipHCheckbox = document.getElementById('flip-h');
  const flipVCheckbox = document.getElementById('flip-v');
  const audioEnabledCheckbox = document.getElementById('audio-enabled');
  const cameraSelect = document.getElementById('camera-select');

  const logEl = document.getElementById('log');
  const logPanel = document.getElementById('log-panel');
  const logToggle = document.getElementById('log-toggle');
  const zoomHint = document.getElementById('zoom-hint');

  // QR
  const qrButton = document.getElementById('qr-button');
  const qrOverlay = document.getElementById('qr-overlay');
  const qrImg = document.getElementById('qr-img');
  const qrClose = document.getElementById('qr-close');
  const QR_URL = 'https://gensai-rika.github.io/camera/';
  qrButton.addEventListener('click', () => {
    const encoded = encodeURIComponent(QR_URL);
    qrImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=400x400&data=${encoded}`;
    qrOverlay.classList.add('open');
  });
  qrClose.addEventListener('click', () => qrOverlay.classList.remove('open'));
  qrOverlay.addEventListener('click', (e) => { if (e.target === qrOverlay) qrOverlay.classList.remove('open'); });

  function log(msg){
    const now = new Date();
    const time = now.toLocaleTimeString();
    logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
  }

  // ===== ã‚«ãƒ¡ãƒ© =====
  let cameraStream = null;
  let currentVideoDeviceId = null;
  let hasInitializedCamera = false;

  // Freeze (pause camera image)
  let isFrozen = false;
  const freezeCanvas = document.createElement('canvas');
  const freezeCtx = freezeCanvas.getContext('2d');
  function setFrozenUI(){
    btnFreeze.textContent = isFrozen ? 'â–¶ï¸' : 'â¸';
    btnFreeze.title = isFrozen ? 'å†é–‹ï¼ˆè§£é™¤ï¼‰' : 'ä¸€æ™‚åœæ­¢ï¼ˆãƒ•ãƒªãƒ¼ã‚ºï¼‰';
    // when frozen, disable starting new record/tl (avoid confusion)
    btnStartRec.disabled = !cameraStream || isFrozen;
    btnStartTl.disabled  = !cameraStream || isFrozen;
  }
  function captureFreezeFrame(){
    // draw current visible frame (incl zoom/filter/flip) into freezeCanvas and set as poster-like background
    const rect = cameraWrapper.getBoundingClientRect();
    const W = Math.max(2, Math.floor(rect.width));
    const H = Math.max(2, Math.floor(rect.height));
    freezeCanvas.width = W;
    freezeCanvas.height = H;

    // Use composite renderer so zoom/filter/flip matches preview
    drawCompositeFrameTo(freezeCtx, W, H, 1); // dpr=1 for freeze poster
    const url = freezeCanvas.toDataURL('image/png');
    video.pause();
    video.style.visibility = 'hidden';
    cameraWrapper.style.backgroundImage = `url(${url})`;
    cameraWrapper.style.backgroundSize = 'cover';
    cameraWrapper.style.backgroundPosition = 'center';
  }
  function unfreeze(){
    cameraWrapper.style.backgroundImage = '';
    video.style.visibility = 'visible';
    try{ video.play(); }catch(e){}
  }

  async function populateCameraList(){
    try{
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(d => d.kind === 'videoinput');
      cameraSelect.innerHTML = '';
      videoDevices.forEach((d, idx) => {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `ã‚«ãƒ¡ãƒ© ${idx+1}`;
        cameraSelect.appendChild(opt);
      });
      if (!currentVideoDeviceId && videoDevices[0]) currentVideoDeviceId = videoDevices[0].deviceId;
      if (currentVideoDeviceId) cameraSelect.value = currentVideoDeviceId;
      cameraSelect.disabled = videoDevices.length <= 1;
    }catch(e){ console.log(e); }
  }

  let audioEnabled = false;
  audioEnabledCheckbox.checked = false;
  audioEnabledCheckbox.addEventListener('change', ()=>{
    audioEnabled = audioEnabledCheckbox.checked;
    log(`éŸ³å£°éŒ²éŸ³: ${audioEnabled ? 'ON':'OFF'}`);
    if (cameraStream) cameraStream.getAudioTracks().forEach(t => t.enabled = audioEnabled);
  });

  async function initCamera(deviceId=null){
    try{
      if (cameraStream) cameraStream.getTracks().forEach(t => t.stop());
      const constraints = {
        video: deviceId
          ? { deviceId:{ exact:deviceId }, width:{ ideal:1920 }, height:{ ideal:1080 } }
          : { width:{ ideal:1920 }, height:{ ideal:1080 } },
        audio: true
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      cameraStream = stream;
      hasInitializedCamera = true;
      cameraStream.getAudioTracks().forEach(t=> t.enabled = audioEnabled);
      video.srcObject = cameraStream;

      // ensure play
      try{ await video.play(); }catch(e){}

      log(deviceId ? 'ã‚«ãƒ¡ãƒ©ã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ':'ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¾ã—ãŸ');

      const enableAfterReady = ()=>{
        resizeCanvases();
        btnShot.disabled = false;
        btnFreeze.disabled = false;
        btnStartRec.disabled = false;
        btnStartTl.disabled = false;
      };
      if (video.readyState >= 1) {
        enableAfterReady();
      } else {
        video.addEventListener('loadedmetadata', enableAfterReady, { once:true });
      }

      btnStartCamera.disabled = true;
      await populateCameraList();
      setFrozenUI();
    }catch(e){
      console.error(e);
      log('ã‚«ãƒ¡ãƒ©ãŒè¨±å¯ã•ã‚Œãªã‹ã£ãŸã‹ã€é¸æŠã—ãŸã‚«ãƒ¡ãƒ©ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã§ã—ãŸ');
    }
  }
  btnStartCamera.addEventListener('click', ()=> initCamera(currentVideoDeviceId));
  cameraSelect.addEventListener('change', ()=>{
    currentVideoDeviceId = cameraSelect.value;
    if (hasInitializedCamera) initCamera(currentVideoDeviceId);
  });

  btnFreeze.addEventListener('click', ()=>{
    if(!cameraStream) return;
    if(isRecording || isTlRecording){
      log('éŒ²ç”»ä¸­ã¯ä¸€æ™‚åœæ­¢ã§ãã¾ã›ã‚“');
      return;
    }
    isFrozen = !isFrozen;
    if(isFrozen){
      captureFreezeFrame();
      log('ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’ä¸€æ™‚åœæ­¢ã—ã¾ã—ãŸ');
    }else{
      unfreeze();
      log('ä¸€æ™‚åœæ­¢ã‚’è§£é™¤ã—ã¾ã—ãŸ');
    }
    setFrozenUI();
  });
  /* â˜…ä¿®æ­£ï¼šclickãŒæ‹¾ã‚ã‚Œãªã„ç’°å¢ƒå¯¾ç­–ï¼ˆç‰¹ã«iPad Safari/ã‚¿ãƒƒãƒï¼‰ */
  btnFreeze.addEventListener('pointerdown', (e)=>{
      e.stopPropagation();
  }, {passive:true});

  // ===== Undoï¼ˆdraw + textï¼‰=====
  const undoStack = [];
  const maxUndo = 50;
  function cloneTextItems(arr){ return arr.map(t => ({...t})); }
  function updateUndoButton(){ btnUndo.disabled = undoStack.length===0; }

  // ===== ã‚ºãƒ¼ãƒ ï¼ˆå…ˆã«å®£è¨€ã—ã¦TDZå›é¿ï¼‰=====
  let zoomMode = false;
  let zoomRect = null;
  let zoomDragStart = null;
  let lastZoomPos = null;

  // ä»Šã®ã‚ºãƒ¼ãƒ å¤‰æ›
  let zoomTransform = { s:1, tx:0, ty:0 };

  function pushUndo(){
    if (!drawCanvas.width || !drawCanvas.height) return;
    try{
      const snapshot = drawCtx.getImageData(0,0,drawCanvas.width,drawCanvas.height);
      undoStack.push({ img:snapshot, texts:cloneTextItems(textItems), selected:selectedTextId, zoomRect: zoomRect ? {...zoomRect} : null });
      if (undoStack.length > maxUndo) undoStack.shift();
      updateUndoButton();
    }catch(e){ console.error(e); }
  }
  function performUndo(){
    if (!undoStack.length) return;
    try{
      const s = undoStack.pop();
      drawCtx.putImageData(s.img,0,0);
      textItems = cloneTextItems(s.texts);
      selectedTextId = s.selected || null;
      zoomRect = s.zoomRect ? {...s.zoomRect} : null;
      updateZoomTransform();

      hideTextEditor();
      uiCtx.clearRect(0,0,uiCanvas.width,uiCanvas.height);
      renderTextLayer();
      log('1ã¤å‰ã®çŠ¶æ…‹ã«æˆ»ã—ã¾ã—ãŸ');
    }catch(e){ console.error(e); }
    updateUndoButton();
  }
  btnUndo.addEventListener('click', performUndo);
  updateUndoButton();

  // ===== ã‚µã‚¤ã‚ºèª¿æ•´ =====
  function resizeCanvases(){
    const rect = cameraWrapper.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    const dpr = window.devicePixelRatio || 1;

    [drawCanvas, uiCanvas].forEach(c=>{
      c.width = width*dpr;
      c.height = height*dpr;
      c.style.width = width+'px';
      c.style.height = height+'px';
    });
    if (toolMode !== 'text') {
      drawCanvas.style.pointerEvents = 'auto';
      textLayer.style.pointerEvents = 'none';
    }

    drawCtx.setTransform(1,0,0,1,0,0);
    uiCtx.setTransform(1,0,0,1,0,0);

    drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
    uiCtx.clearRect(0,0,uiCanvas.width,uiCanvas.height);

    zoomRect = null;
    updateZoomTransform();

    undoStack.length = 0;
    updateUndoButton();
    renderTextLayer();
  }

  window.addEventListener('resize', ()=>{
    if (video.videoWidth) resizeCanvases();
    if (textEditor.style.display !== 'none') positionEditorToSelected();
  });

  // ===== ãƒ„ãƒ¼ãƒ« =====
  let toolMode = 'pen'; // pen|eraser|shape|text

  const pens = [
    { color:'#ffffff', size:10 },
    { color:'#ff0000', size:10 },
    { color:'#7dd3fc', size:10 }
  ];
  let activePenIndex = 1;
  let eraserSize = 30;

  const penConfigs = [
    { panel: document.getElementById('pen-config-0'), colorInput: document.getElementById('pen-color-0'), sizeInput: document.getElementById('pen-size-0') },
    { panel: document.getElementById('pen-config-1'), colorInput: document.getElementById('pen-color-1'), sizeInput: document.getElementById('pen-size-1') },
    { panel: document.getElementById('pen-config-2'), colorInput: document.getElementById('pen-color-2'), sizeInput: document.getElementById('pen-size-2') }
  ];
  const eraserConfigPanel = document.getElementById('eraser-config');
  const eraserSizeInput = document.getElementById('eraser-size');
  let openPenConfigIndex = null;

  let shapeColor = '#ffffff';
  const SHAPE_LINE_WIDTH = 10;
  function updateShapeIconColor(){
    toolShapeBtn.style.background = shapeColor;
    const r = parseInt(shapeColor.slice(1,3),16);
    const g = parseInt(shapeColor.slice(3,5),16);
    const b = parseInt(shapeColor.slice(5,7),16);
    const y = 0.299*r + 0.587*g + 0.114*b;
    toolShapeBtn.style.color = (y>160) ? '#000' : '#fff';
  }
  updateShapeIconColor();
  shapeColorInput.value = shapeColor;
  shapeColorInput.addEventListener('input', ()=>{
    shapeColor = shapeColorInput.value;
    updateShapeIconColor();
    log(`é¢ã®è‰²å¤‰æ›´: ${shapeColor}`);
  });

  function showPanelUnder(panel, anchorEl){
    if (!panel || !anchorEl) return;
    panel.style.display='block';
    panel.style.visibility='hidden';
    const rect = anchorEl.getBoundingClientRect();
    const pRect = panel.getBoundingClientRect();
    let left = rect.left;
    if (left + pRect.width > window.innerWidth - 8) left = window.innerWidth - pRect.width - 8;
    if (left < 8) left = 8;
    const top = rect.bottom + 4;
    panel.style.left = `${left}px`;
    panel.style.top  = `${top}px`;
    panel.style.visibility='visible';
  }
  function hidePanel(panel){ if(panel) panel.style.display='none'; }
  function hideAllToolPanels(){
    penConfigs.forEach(c=>hidePanel(c.panel));
    hidePanel(eraserConfigPanel);
    hidePanel(shapeConfigPanel);
    hidePanel(textConfigPanel);
    openPenConfigIndex = null;
  }

  function updateSwatchVisual(index){
    const btn = swatchButtons[index];
    if(!btn) return;
    const circle = btn.querySelector('.swatch-circle');
    const pen = pens[index];
    circle.style.background = pen.color;
    const minSize=10,maxSize=26;
    const minW=1,maxW=40;
    const t = Math.max(minW, Math.min(maxW, pen.size));
    const ratio = (t-minW)/(maxW-minW);
    const size = minSize + (maxSize-minSize)*ratio;
    circle.style.width = `${size}px`;
    circle.style.height = `${size}px`;
  }
  function updateAllSwatches(){ pens.forEach((_,i)=>updateSwatchVisual(i)); }

  function setActivePen(index){
    activePenIndex = index;
    swatchButtons.forEach(btn=>{
      const i = Number(btn.dataset.penIndex);
      btn.classList.toggle('active', i===index);
    });
  }

  function setToolMode(mode){
    toolMode = mode;
    toolEraserBtn.classList.toggle('active', mode==='eraser');
    toolShapeBtn.classList.toggle('active', mode==='shape');
    toolTextBtn.classList.toggle('active', mode==='text');
    if (mode==='eraser') drawCtx.globalCompositeOperation='destination-out';
    else drawCtx.globalCompositeOperation='source-over';
  }

  setToolMode('pen');
  setActivePen(1);
  updateAllSwatches();
  eraserSizeInput.value = eraserSize;

  pens.forEach((pen, idx)=>{
    penConfigs[idx].colorInput.value = pen.color;
    penConfigs[idx].sizeInput.value = pen.size;
    penConfigs[idx].colorInput.addEventListener('input', ()=>{
      pen.color = penConfigs[idx].colorInput.value;
      updateSwatchVisual(idx);
      log(`ãƒšãƒ³${idx+1} è‰²å¤‰æ›´: ${pen.color}`);
    });
    penConfigs[idx].sizeInput.addEventListener('input', ()=>{
      pen.size = Number(penConfigs[idx].sizeInput.value) || 1;
      updateSwatchVisual(idx);
      log(`ãƒšãƒ³${idx+1} å¤ªã•å¤‰æ›´: ${pen.size}px`);
    });
  });
  eraserSizeInput.addEventListener('input', ()=>{
    eraserSize = Number(eraserSizeInput.value) || 1;
    log(`æ¶ˆã—ã‚´ãƒ  å¤ªã•å¤‰æ›´: ${eraserSize}px`);
  });

  swatchButtons.forEach(btn=>{
    const idx = Number(btn.dataset.penIndex);
    btn.addEventListener('click', ()=>{
      const same = (openPenConfigIndex===idx && penConfigs[idx].panel.style.display==='block');
      setToolMode('pen');
      setActivePen(idx);
      hideAllToolPanels();
      hideTextEditor();
      if (!same){
        openPenConfigIndex = idx;
        showPanelUnder(penConfigs[idx].panel, btn);
      }else openPenConfigIndex = null;
    });
  });

  toolEraserBtn.addEventListener('click', ()=>{
    const will = toolMode!=='eraser';
    hideAllToolPanels(); hideTextEditor();
    if (will){
      setToolMode('eraser');
      showPanelUnder(eraserConfigPanel, toolEraserBtn);
      log('ãƒ„ãƒ¼ãƒ«: æ¶ˆã—ã‚´ãƒ ');
    }else{
      setToolMode('pen');
      log('ãƒ„ãƒ¼ãƒ«: ãƒšãƒ³');
    }
  });
  toolShapeBtn.addEventListener('click', ()=>{
    const will = toolMode!=='shape';
    hideAllToolPanels(); hideTextEditor();
    if (will){
      setToolMode('shape');
      showPanelUnder(shapeConfigPanel, toolShapeBtn);
      log('ãƒ„ãƒ¼ãƒ«: é¢ï¼ˆå››è§’ï¼‰');
    }else{
      setToolMode('pen');
      log('ãƒ„ãƒ¼ãƒ«: ãƒšãƒ³');
    }
  });
  toolTextBtn.addEventListener('click', ()=>{
    const will = toolMode!=='text';
    hideAllToolPanels(); hideTextEditor();
    if (will){
      setToolMode('text');
      showPanelUnder(textConfigPanel, toolTextBtn);
      syncTextPanelWithSelected();
      log('ãƒ„ãƒ¼ãƒ«: ãƒ†ã‚­ã‚¹ãƒˆï¼ˆã‚¯ãƒªãƒƒã‚¯ã§ãƒœãƒƒã‚¯ã‚¹è¿½åŠ ï¼‰');
      textLayer.style.pointerEvents = 'auto';
      drawCanvas.style.pointerEvents = 'none';
      updateSelectionVisual();
    }else{
      setToolMode('pen');
      log('ãƒ„ãƒ¼ãƒ«: ãƒšãƒ³');
      textLayer.style.pointerEvents = 'none';
      drawCanvas.style.pointerEvents = 'auto';
      deselectText();
    }
  });

  // ===== ãƒ­ã‚°/æ˜ åƒãƒ‘ãƒãƒ« =====
  logToggle.addEventListener('click', ()=> logPanel.classList.toggle('open'));
  videoSettingsToggle.addEventListener('click', ()=>{
    videoPanel.style.display = (videoPanel.style.display==='block') ? 'none':'block';
  });

  // ===== ãƒ•ã‚£ãƒ«ã‚¿/åè»¢ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰=====
  const settings = { brightness:1, contrast:1, exposure:0, colorTemp:0, sharpness:0, lineBoost:false, noiseReduce:false };
  let videoFilterString = 'brightness(1) contrast(1)';
  let flipH = true;
  let flipV = false;

  function updateVideoFilter(){
    const exposureFactor = Math.pow(2, settings.exposure);
    const b = settings.brightness * exposureFactor;
    const c = settings.contrast;
    const t = settings.colorTemp;

    let filter = `brightness(${b}) contrast(${c})`;
    if (t > 0){
      const amt = t;
      filter += ` sepia(${amt}) saturate(${1 + 0.5*amt}) hue-rotate(-10deg)`;
    }else if (t < 0){
      const amt = -t;
      filter += ` saturate(${1 - 0.3*amt}) hue-rotate(${amt * 20}deg)`;
    }
    videoFilterString = filter;
    video.style.filter = filter;
  }
  function updateVideoFlipPreview(){
    const sx = flipH ? -1 : 1;
    const sy = flipV ? -1 : 1;
    video.style.transform = `scaleX(${sx}) scaleY(${sy})`;
  }

  brightnessSlider.addEventListener('input', ()=>{ settings.brightness=parseFloat(brightnessSlider.value)||1; updateVideoFilter(); });
  contrastSlider.addEventListener('input', ()=>{ settings.contrast=parseFloat(contrastSlider.value)||1; updateVideoFilter(); });
  exposureSlider.addEventListener('input', ()=>{ settings.exposure=parseFloat(exposureSlider.value)||0; updateVideoFilter(); });
  colorTempSlider.addEventListener('input', ()=>{ settings.colorTemp=parseFloat(colorTempSlider.value)||0; updateVideoFilter(); });
  sharpnessSlider.addEventListener('input', ()=>{ settings.sharpness=parseFloat(sharpnessSlider.value)||0; });
  lineBoostCheckbox.addEventListener('change', ()=>{ settings.lineBoost=lineBoostCheckbox.checked; log(`ç·šãƒ»æ–‡å­—ãã£ãã‚Š: ${settings.lineBoost?'ON':'OFF'}`); });
  noiseReduceCheckbox.addEventListener('change', ()=>{ settings.noiseReduce=noiseReduceCheckbox.checked; log(`ãƒã‚¤ã‚ºè»½æ¸›: ${settings.noiseReduce?'ON':'OFF'}`); });
  flipHCheckbox.addEventListener('change', ()=>{ flipH=flipHCheckbox.checked; updateVideoFlipPreview(); log(`å·¦å³åè»¢: ${flipH?'ON':'OFF'}`); });
  flipVCheckbox.addEventListener('change', ()=>{ flipV=flipVCheckbox.checked; updateVideoFlipPreview(); log(`ä¸Šä¸‹åè»¢: ${flipV?'ON':'OFF'}`); });
  updateVideoFilter();
  updateVideoFlipPreview();

  // ===== ãƒ†ã‚­ã‚¹ãƒˆ =====
  let textDefaults = { color:'#ffffff', size:36, font:'system-ui, -apple-system, BlinkMacSystemFont' };
  let textItems = [];
  let selectedTextId = null;

  let isDraggingText = false;
  let isResizingText = false;
  let dragOffset = {x:0,y:0};
  let resizeStart = null;
  let activePointerId = null;

  function newId(){ return Math.random().toString(36).slice(2,9) + Date.now().toString(36).slice(-4); }
  function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function getSelectedText(){ return textItems.find(t=>t.id===selectedTextId) || null; }

  function applyTextStyleToElement(el,item){
    const content = el.querySelector('.text-content');
    content.style.color = item.color;
    content.style.fontSize = item.size + 'px';
    content.style.fontFamily = item.font;
    content.innerHTML = escapeHtml(item.text || '');
  }

  function updateSelectionVisual(){
    const boxes = textLayer.querySelectorAll('.text-box');
    boxes.forEach(b=>{
      b.classList.toggle('selected', b.dataset.id === selectedTextId);
    });
  }

  function selectTextSoft(id){
    selectedTextId = id;
    updateSelectionVisual();
    syncTextPanelWithSelected();
    showPanelUnder(textConfigPanel, toolTextBtn);
  }

  function renderTextLayer(){
    textLayer.innerHTML = '';
    for (const item of textItems){
      const box = document.createElement('div');
      box.className = 'text-box';
      box.dataset.id = item.id;
      box.style.left = item.x + 'px';
      box.style.top  = item.y + 'px';
      box.style.width  = item.w + 'px';
      box.style.height = item.h + 'px';

      const content = document.createElement('div');
      content.className = 'text-content';
      box.appendChild(content);

      const handle = document.createElement('div');
      handle.className = 'resize-handle';
      handle.title = 'æ‹¡å¤§ç¸®å°';
      box.appendChild(handle);

      applyTextStyleToElement(box,item);

      box.addEventListener('pointerdown', (e)=>{
        e.stopPropagation();
        if (zoomMode) return;

        suppressBlurCommit = true;

        selectTextSoft(item.id);
        pushUndo();

        activePointerId = e.pointerId;

        const p = clientToInnerCss(e.clientX, e.clientY);

        if (e.target.classList.contains('resize-handle')){
          isResizingText = true;
          isDraggingText = false;
          resizeStart = {
            id: item.id,
            startX: p.x,
            startY: p.y,
            startW: item.w,
            startH: item.h
          };
        }else{
          isDraggingText = true;
          isResizingText = false;
          dragOffset.x = p.x - item.x;
          dragOffset.y = p.y - item.y;
        }

        try{
          if (box.setPointerCapture) box.setPointerCapture(e.pointerId);
        }catch(err){
          console.warn('setPointerCapture failed:', err);
        }
      });

      box.addEventListener('dblclick', (e)=>{
        e.stopPropagation();
        if (zoomMode) return;
        selectTextSoft(item.id);
        beginEditSelectedText(true);
      });

      box.addEventListener('pointermove', (e)=>{
        if (zoomMode) return;
        if (e.pointerId !== activePointerId) return;
        if (!isDraggingText && !isResizingText) return;

        const it = textItems.find(t=>t.id===box.dataset.id);
        if (!it) return;

        const p = clientToInnerCss(e.clientX, e.clientY);

        if (isDraggingText){
          let nx = p.x - dragOffset.x;
          let ny = p.y - dragOffset.y;
          nx = Math.max(-500, Math.min(nx, cameraWrapper.clientWidth + 500));
          ny = Math.max(-500, Math.min(ny, cameraWrapper.clientHeight + 500));
          it.x = nx; it.y = ny;
          box.style.left = it.x+'px';
          box.style.top  = it.y+'px';
          if (textEditor.style.display !== 'none') positionEditorToSelected();
        }

        if (isResizingText && resizeStart && resizeStart.id===it.id){
          const dx = p.x - resizeStart.startX;
          const dy = p.y - resizeStart.startY;
          it.w = Math.max(24, resizeStart.startW + dx);
          it.h = Math.max(18, resizeStart.startH + dy);
          box.style.width  = it.w+'px';
          box.style.height = it.h+'px';
          if (textEditor.style.display !== 'none') positionEditorToSelected();
        }
      });

      function endTextOp(){
        if (isDraggingText || isResizingText){
          isDraggingText = false;
          isResizingText = false;
          resizeStart = null;
          activePointerId = null;
          suppressBlurCommit = false;
        }
      }

      box.addEventListener('pointerup', (e)=>{
        if (e.pointerId !== activePointerId) return;
        endTextOp();
      });
      box.addEventListener('pointercancel', (e)=>{
        if (e.pointerId !== activePointerId) return;
        endTextOp();
      });

      textLayer.appendChild(box);
    }
    updateSelectionVisual();
    syncTextPanelWithSelected();
  }

  function deselectText(){
    selectedTextId = null;
    hideTextEditor();
    updateSelectionVisual();
    syncTextPanelWithSelected();
  }

  function syncTextPanelWithSelected(){
    const it = getSelectedText();
    const enabled = !!it;
    textConfigPanel.querySelectorAll('input,select,button').forEach(el=> el.disabled = !enabled);
    if (!it) return;
    textColorInput.value = it.color;
    textSizeInput.value = it.size;
    const opt = Array.from(textFontSelect.options).find(o=>o.value===it.font);
    if (opt) textFontSelect.value = it.font;
  }

  function addTextBoxAt(cssX, cssY){
    const id = newId();
    const item = {
      id,
      x: cssX,
      y: cssY,
      w: 220,
      h: 80,
      text: '',
      color: textDefaults.color,
      size: textDefaults.size,
      font: textDefaults.font
    };
    pushUndo();
    textItems.push(item);
    selectedTextId = id;
    renderTextLayer();
    showPanelUnder(textConfigPanel, toolTextBtn);
    beginEditSelectedText(true);
    log('ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼ˆç·¨é›†ã—ã¦ç¢ºå®šã—ã¦ãã ã•ã„ï¼‰');
  }

  function positionEditorToSelected(){
    const it = getSelectedText();
    if (!it) return;

    const box = textLayer.querySelector(`.text-box[data-id="${it.id}"]`);
    if (!box) return;

    const boxRect = box.getBoundingClientRect();
    const wrapRect = cameraWrapper.getBoundingClientRect();
    const left = boxRect.left - wrapRect.left;
    const top  = boxRect.top  - wrapRect.top;

    textEditor.style.left = left+'px';
    textEditor.style.top  = top +'px';
    textEditor.style.width  = boxRect.width+'px';
    textEditor.style.height = boxRect.height+'px';
  }

  function beginEditSelectedText(focusAll=false){
    const it = getSelectedText();
    if(!it) return;
    if (isDraggingText || isResizingText) return;

    positionEditorToSelected();

    textEditorTa.value = it.text || '';
    textEditorTa.style.color = it.color;
    textEditorTa.style.fontSize = it.size+'px';
    textEditorTa.style.fontFamily = it.font;
    textEditor.style.display = 'block';

    requestAnimationFrame(()=>{
      textEditorTa.focus();
      if (focusAll) textEditorTa.setSelectionRange(0, textEditorTa.value.length);
    });
  }

  function commitEditSelectedText(){
    const it = getSelectedText();
    if(!it) return;
    it.text = textEditorTa.value;
    hideTextEditor();
    renderTextLayer();
    log('ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°ã—ã¾ã—ãŸ');
  }

  function hideTextEditor(){ textEditor.style.display = 'none'; }

  let suppressBlurCommit = false;
  textEditorTa.addEventListener('blur', ()=>{
    if (textEditor.style.display==='none') return;
    if (suppressBlurCommit) return;
    if (isDraggingText || isResizingText) return;
    commitEditSelectedText();
  });

  textEditorTa.addEventListener('keydown', (e)=>{
    if (e.key==='Enter' && !e.shiftKey){
      e.preventDefault();
      commitEditSelectedText();
    }
    if (e.key==='Escape'){
      e.preventDefault();
      hideTextEditor();
      renderTextLayer();
    }
  });

  textColorInput.addEventListener('input', ()=>{
    const it = getSelectedText();
    const v = textColorInput.value;
    textDefaults.color = v;
    if(it){
      it.color = v;
      textEditorTa.style.color = v;
      renderTextLayer();
    }
  });
  textSizeInput.addEventListener('input', ()=>{
    const it = getSelectedText();
    const v = Number(textSizeInput.value) || 36;
    textDefaults.size = v;
    if(it){
      it.size = v;
      textEditorTa.style.fontSize = v+'px';
      renderTextLayer();
      if(textEditor.style.display!=='none') positionEditorToSelected();
    }
  });
  textFontSelect.addEventListener('change', ()=>{
    const it = getSelectedText();
    const v = textFontSelect.value;
    textDefaults.font = v;
    if(it){
      it.font = v;
      textEditorTa.style.fontFamily = v;
      renderTextLayer();
    }
  });
  textEditBtn.addEventListener('click', ()=> beginEditSelectedText(true));
  textDeleteBtn.addEventListener('click', ()=>{
    const it = getSelectedText();
    if(!it) return;
    pushUndo();
    textItems = textItems.filter(t=>t.id!==it.id);
    selectedTextId = null;
    hideTextEditor();
    renderTextLayer();
    log('ãƒ†ã‚­ã‚¹ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
  });

  function clientToInnerCss(clientX, clientY){
    const wrapRect = cameraWrapper.getBoundingClientRect();
    let x = clientX - wrapRect.left;
    let y = clientY - wrapRect.top;
    x = (x - zoomTransform.tx) / zoomTransform.s;
    y = (y - zoomTransform.ty) / zoomTransform.s;
    return {x,y};
  }

  cameraWrapper.addEventListener('pointerdown', (e)=>{
    if(zoomMode) return;
    const path = e.composedPath ? e.composedPath() : [];
    const hitText = path.some(p=> p && p.classList && p.classList.contains('text-box'));
    const hitEditor = path.some(p=> p && p.id==='text-editor-ta');
    if(!hitText && !hitEditor){
      if(toolMode!=='text') deselectText();
    }
  }, {capture:true});

  // ===== æç”»/é¢ =====
  let isDrawing = false;
  let lastX=0,lastY=0;
  let shapeDragStart = null;
  let lastShapePos = null;

  function getCanvasPosInternal(e){
    const rect = drawCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (drawCanvas.width / rect.width);
    const y = (e.clientY - rect.top)  * (drawCanvas.height/ rect.height);
    return {x,y};
  }

  // ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ 
  textLayer.addEventListener('pointerdown', (e) => {
    if (zoomMode) return;
    if (toolMode !== 'text') return;

    const hitText = e.target.closest && e.target.closest('.text-box');
    const hitEditor = (e.target.id === 'text-editor-ta') || (e.target.closest && e.target.closest('#text-editor'));
    if (hitText || hitEditor) return;

    e.preventDefault();
    e.stopPropagation();

    const p = clientToInnerCss(e.clientX, e.clientY);
    addTextBoxAt(p.x, p.y);
  }, { passive: false });

  function startDraw(e){
    if(zoomMode) return;
    if(toolMode==='text') return;
    e.preventDefault();
    pushUndo();

    const pos = getCanvasPosInternal(e);
    if(toolMode==='shape'){
      isDrawing = true;
      shapeDragStart = pos;
      lastShapePos = pos;
      uiCtx.clearRect(0,0,uiCanvas.width,uiCanvas.height);
      return;
    }

    isDrawing = true;
    lastX = pos.x; lastY = pos.y;
  }

  function draw(e){
    if(!isDrawing || zoomMode) return;
    e.preventDefault();
    const pos = getCanvasPosInternal(e);

    if(toolMode==='shape'){
      if(!shapeDragStart) return;
      lastShapePos = pos;
      uiCtx.clearRect(0,0,uiCanvas.width,uiCanvas.height);
      uiCtx.save();
      uiCtx.strokeStyle = shapeColor;
      uiCtx.lineWidth = SHAPE_LINE_WIDTH;
      uiCtx.setLineDash([6,4]);
      const x = Math.min(shapeDragStart.x, pos.x);
      const y = Math.min(shapeDragStart.y, pos.y);
      const w = Math.abs(pos.x - shapeDragStart.x);
      const h = Math.abs(pos.y - shapeDragStart.y);
      uiCtx.strokeRect(x,y,w,h);
      uiCtx.restore();
      return;
    }

    if(toolMode==='eraser'){
      drawCtx.strokeStyle = 'rgba(0,0,0,1)';
      drawCtx.lineWidth = eraserSize;
    }else{
      const pen = pens[activePenIndex];
      drawCtx.strokeStyle = pen.color;
      drawCtx.lineWidth = pen.size;
    }
    drawCtx.lineCap='round';
    drawCtx.lineJoin='round';
    drawCtx.beginPath();
    drawCtx.moveTo(lastX,lastY);
    drawCtx.lineTo(pos.x,pos.y);
    drawCtx.stroke();
    lastX = pos.x; lastY = pos.y;
  }

  function endDraw(e){
    if(!isDrawing) return;
    e.preventDefault();

    if(toolMode==='shape' && shapeDragStart && lastShapePos){
      const x = Math.min(shapeDragStart.x, lastShapePos.x);
      const y = Math.min(shapeDragStart.y, lastShapePos.y);
      const w = Math.abs(lastShapePos.x - shapeDragStart.x);
      const h = Math.abs(lastShapePos.y - shapeDragStart.y);
      const minSize=4;
      if(w>=minSize && h>=minSize){
        const prevOp = drawCtx.globalCompositeOperation;
        drawCtx.globalCompositeOperation='source-over';
        drawCtx.save();
        drawCtx.fillStyle = shapeColor;
        drawCtx.strokeStyle = shapeColor;
        drawCtx.lineWidth = SHAPE_LINE_WIDTH;
        drawCtx.fillRect(x,y,w,h);
        drawCtx.strokeRect(x,y,w,h);
        drawCtx.restore();
        drawCtx.globalCompositeOperation = prevOp;
      }
      uiCtx.clearRect(0,0,uiCanvas.width,uiCanvas.height);
      shapeDragStart=null; lastShapePos=null;
    }

    isDrawing=false;
  }

  drawCanvas.addEventListener('pointerdown', startDraw, {passive:false});
  drawCanvas.addEventListener('pointermove', draw, {passive:false});
  drawCanvas.addEventListener('pointerup', endDraw, {passive:false});
  drawCanvas.addEventListener('pointercancel', endDraw, {passive:false});
  drawCanvas.addEventListener('pointerleave', endDraw, {passive:false});

  btnClear.addEventListener('click', ()=>{
    pushUndo();
    drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
    uiCtx.clearRect(0,0,uiCanvas.width,uiCanvas.height);
    log('æ‰‹æããƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼ˆãƒ†ã‚­ã‚¹ãƒˆã¯æ®‹ã‚Šã¾ã™ï¼‰');
  });

  function clearUiCanvas(){ uiCtx.clearRect(0,0,uiCanvas.width,uiCanvas.height); }

  function updateZoomTransform(){
    if(!zoomRect){
      zoomTransform = { s:1, tx:0, ty:0 };
      cameraInner.style.transform = 'translate(0px,0px) scale(1)';
      if(textEditor.style.display!=='none') positionEditorToSelected();
      return;
    }
    const W = cameraWrapper.clientWidth;
    const H = cameraWrapper.clientHeight;
    if(!W||!H) return;

    const r = zoomRect;
    const s = Math.max(W/r.w, H/r.h);
    const cx = r.x + r.w/2;
    const cy = r.y + r.h/2;
    const tx = (W/2) - s*cx;
    const ty = (H/2) - s*cy;

    zoomTransform = { s, tx, ty };
    cameraInner.style.transform = `translate(${tx}px, ${ty}px) scale(${s})`;
    if(textEditor.style.display!=='none') positionEditorToSelected();
  }

  function enterZoomMode(){
    zoomMode = true;
    zoomDragStart=null; lastZoomPos=null;
    clearUiCanvas();
    zoomHint.classList.add('visible');
    drawCanvas.style.pointerEvents='none';
    textLayer.style.pointerEvents='none';
    hideTextEditor();
    log('ã‚ºãƒ¼ãƒ é ˜åŸŸé¸æŠãƒ¢ãƒ¼ãƒ‰ï¼šæ˜ åƒä¸Šã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãã ã•ã„');
  }
  function exitZoomMode(){
    zoomMode = false;
    zoomDragStart=null; lastZoomPos=null;
    clearUiCanvas();
    zoomHint.classList.remove('visible');
    drawCanvas.style.pointerEvents = (toolMode==='text') ? 'none':'auto';
    textLayer.style.pointerEvents = (toolMode==='text') ? 'auto':'none';
  }

  btnZoomSelect.addEventListener('click', ()=>{
    if(!video.videoWidth){ log('ã‚«ãƒ¡ãƒ©èµ·å‹•å¾Œã«ã‚ºãƒ¼ãƒ ã§ãã¾ã™'); return; }
    enterZoomMode();
  });
  btnZoomReset.addEventListener('click', ()=>{
    zoomRect=null;
    updateZoomTransform();
    exitZoomMode();
    log('ã‚ºãƒ¼ãƒ ã‚’è§£é™¤ã—ã¾ã—ãŸ');
  });

  function getWrapperPosFromClient(clientX,clientY){
    const rect = cameraWrapper.getBoundingClientRect();
    return { x: clientX-rect.left, y: clientY-rect.top };
  }

  function drawZoomRectPreview(currentPos){
    const start = zoomDragStart;
    clearUiCanvas();
    uiCtx.strokeStyle='#00ff88';
    uiCtx.lineWidth=2;
    uiCtx.setLineDash([6,4]);

    const rect = cameraWrapper.getBoundingClientRect();
    const scaleX = uiCanvas.width / rect.width;
    const scaleY = uiCanvas.height/ rect.height;

    const x = Math.min(start.x, currentPos.x) * scaleX;
    const y = Math.min(start.y, currentPos.y) * scaleY;
    const w = Math.abs(currentPos.x-start.x) * scaleX;
    const h = Math.abs(currentPos.y-start.y) * scaleY;
    uiCtx.strokeRect(x,y,w,h);
    uiCtx.setLineDash([]);
  }

  function finalizeZoom(endPosMaybe){
    const endPos = endPosMaybe || lastZoomPos || zoomDragStart;
    if(!zoomDragStart || !endPos){ clearUiCanvas(); log('ã‚ºãƒ¼ãƒ ç¯„å›²ãŒæ±ºå®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }

    const x0=zoomDragStart.x, y0=zoomDragStart.y;
    const x1=endPos.x, y1=endPos.y;
    const rx=Math.min(x0,x1);
    const ry=Math.min(y0,y1);
    const rw=Math.abs(x1-x0);
    const rh=Math.abs(y1-y0);

    const minSize=20;
    if(rw<minSize || rh<minSize){ clearUiCanvas(); log('é¸æŠç¯„å›²ãŒå°ã•ã™ãã¾ã™'); return; }

    const W=cameraWrapper.clientWidth, H=cameraWrapper.clientHeight;
    const rxC=Math.max(0,Math.min(rx,W));
    const ryC=Math.max(0,Math.min(ry,H));
    const rwC=Math.min(rw,W-rxC);
    const rhC=Math.min(rh,H-ryC);

    zoomRect={ x:rxC, y:ryC, w:rwC, h:rhC };
    updateZoomTransform();
    exitZoomMode();
    log('ã‚ºãƒ¼ãƒ ã‚’é©ç”¨ã—ã¾ã—ãŸ');
  }

  cameraWrapper.addEventListener('pointerdown', (e)=>{
    if(!zoomMode) return;
    e.preventDefault();
    const pos = getWrapperPosFromClient(e.clientX,e.clientY);
    zoomDragStart=pos; lastZoomPos=pos;
  }, {capture:true});

  cameraWrapper.addEventListener('pointermove', (e)=>{
    if(!zoomMode || !zoomDragStart) return;
    e.preventDefault();
    const pos = getWrapperPosFromClient(e.clientX,e.clientY);
    lastZoomPos=pos;
    drawZoomRectPreview(pos);
  }, {capture:true});

  cameraWrapper.addEventListener('pointerup', (e)=>{
    if(!zoomMode || !zoomDragStart) return;
    e.preventDefault();
    const pos = getWrapperPosFromClient(e.clientX,e.clientY);
    lastZoomPos=pos;
    finalizeZoom(pos);
  }, {capture:true});

  // ===== é™æ­¢ç”»/éŒ²ç”»å…±é€šã®åˆæˆæç”» =====
  const compositeCanvas = document.createElement('canvas');
  const compositeCtx = compositeCanvas.getContext('2d');

  function drawTextItemsOnComposite(ctx){
    for(const t of textItems){
      const txt = (t.text||'').trimEnd();
      if(!txt) continue;
      ctx.save();
      ctx.fillStyle=t.color;
      ctx.font=`${t.size}px ${t.font}`;
      ctx.textBaseline='top';
      const lines = txt.split('\\n');
      const lineH = Math.round(t.size*1.25);
      let yy=t.y;
      for(const line of lines){
        ctx.fillText(line, t.x, yy);
        yy += lineH;
      }
      ctx.restore();
    }
  }

  // draw composite frame onto arbitrary ctx with explicit size and dprScale
  function drawCompositeFrameTo(ctx, Wcss, Hcss, dprScale){
    // ctx uses pixel units already (caller sets canvas size)
    // Here we draw in CSS units by scaling
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle='black';
    ctx.fillRect(0,0,Wcss*dprScale,Hcss*dprScale);
    ctx.scale(dprScale,dprScale);

    let s=1, tx=0, ty=0;
    if(zoomRect){
      const r=zoomRect;
      const sZoom = Math.max(Wcss/r.w, Hcss/r.h);
      const cx=r.x+r.w/2, cy=r.y+r.h/2;
      tx=(Wcss/2)-sZoom*cx;
      ty=(Hcss/2)-sZoom*cy;
      s=sZoom;
    }
    ctx.translate(tx,ty);
    ctx.scale(s,s);

    const vw=video.videoWidth, vh=video.videoHeight;
    if(!vw || !vh) return;
    const s0=Math.max(Wcss/vw, Hcss/vh);
    const vsW=vw*s0, vsH=vh*s0;
    const dx=(Wcss-vsW)/2, dy=(Hcss-vsH)/2;

    ctx.save();
    ctx.filter = videoFilterString || 'none';
    let drawTx=dx, drawTy=dy, scaleX=1, scaleY=1;
    if(flipH){ drawTx = dx+vsW; scaleX=-1; }
    if(flipV){ drawTy = dy+vsH; scaleY=-1; }
    ctx.translate(drawTx,drawTy);
    ctx.scale(scaleX,scaleY);
    ctx.scale(s0,s0);

    // If frozen, use freeze frame from background? simplest: use current video still.
    ctx.drawImage(video,0,0,vw,vh);
    ctx.restore();

    // draw drawing layer and texts
    ctx.drawImage(drawCanvas, 0,0,drawCanvas.width,drawCanvas.height, 0,0, Wcss,Hcss);
    drawTextItemsOnComposite(ctx);
  }

  function drawCompositeFrame(){
    const rect = cameraWrapper.getBoundingClientRect();
    const Wcss = rect.width, Hcss = rect.height;
    const dpr = window.devicePixelRatio || 1;

    compositeCanvas.width  = Math.floor(Wcss*dpr);
    compositeCanvas.height = Math.floor(Hcss*dpr);

    drawCompositeFrameTo(compositeCtx, Wcss, Hcss, dpr);
  }

  btnShot.addEventListener('click', ()=>{
    drawCompositeFrame();
    const url = compositeCanvas.toDataURL('image/png');
    const a=document.createElement('a');
    const ts=new Date().toISOString().replace(/[:.]/g,'-');
    a.href=url;
    a.download=`snapshot_${ts}.png`;
    a.click();
    log('é™æ­¢ç”»ã‚’PNGã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸï¼ˆãƒ†ã‚­ã‚¹ãƒˆã‚‚åæ˜ ï¼‰');
  });

  // ===== éŒ²ç”»ï¼ˆå‹•ç”»ï¼‰ =====
  let isRecording = false;
  let recorder = null;
  let recordChunks = [];
  let recStartTs = 0;
  let recTimerInterval = null;

  // We record from compositeCanvas stream, NOT from video, so zoom/filter/text are included reliably.
  function pickSupportedMime(){
    const candidates = [
      'video/webm;codecs=vp9,opus',
      'video/webm;codecs=vp8,opus',
      'video/webm;codecs=vp9',
      'video/webm;codecs=vp8',
      'video/webm'
    ];
    return candidates.find(t => MediaRecorder.isTypeSupported(t)) || '';
  }

  function fmtTime(ms){
    const sec = Math.floor(ms/1000);
    const m = String(Math.floor(sec/60)).padStart(2,'0');
    const s = String(sec%60).padStart(2,'0');
    return `${m}:${s}`;
  }

  function startRecTimer(){
    recStartTs = performance.now();
    recTimerEl.textContent = '00:00';
    if(recTimerInterval) clearInterval(recTimerInterval);
    recTimerInterval = setInterval(()=>{
      recTimerEl.textContent = fmtTime(performance.now()-recStartTs);
    }, 250);
  }
  function stopRecTimer(){
    if(recTimerInterval) clearInterval(recTimerInterval);
    recTimerInterval = null;
    recTimerEl.textContent = '00:00';
  }

  // draw loop for recording at desired fps
  let recDrawRaf = null;
  function startCompositeDrawLoop(targetFps){
    const fps = Math.max(1, Math.min(60, targetFps||30));
    const frameMs = 1000 / fps;
    let last = 0;

    const rect = cameraWrapper.getBoundingClientRect();
    const Wcss = rect.width, Hcss = rect.height;
    const dpr = window.devicePixelRatio || 1;
    compositeCanvas.width  = Math.floor(Wcss*dpr);
    compositeCanvas.height = Math.floor(Hcss*dpr);

    function loop(ts){
      if(!isRecording) return;
      if(ts - last >= frameMs){
        last = ts;
        // If frozen, keep drawing last frame: composite still uses video current but video is hidden/paused.
        // So we reuse freezeFrame by drawing from freezeCanvas if frozen.
        if(isFrozen){
          // draw freezeCanvas as background
          compositeCtx.setTransform(1,0,0,1,0,0);
          compositeCtx.drawImage(freezeCanvas, 0,0, compositeCanvas.width, compositeCanvas.height);
          // then overlay draw/text with zoom transform (freeze is already zoomed, so we overlay in screen space)
          const W = Wcss, H = Hcss;
          compositeCtx.save();
          compositeCtx.scale(dpr,dpr);
          // overlay draw and text in current zoomed space
          // easiest: redraw overlays by calling drawCompositeFrameTo but background replaced; so:
          compositeCtx.restore();
          // Just call full draw for overlays using video (will be stale) => instead: do complete drawCompositeFrameTo using video won't work.
          // Simpler: while frozen, do not allow recording start; already disabled. So this block shouldn't happen.
        }else{
          drawCompositeFrameTo(compositeCtx, Wcss, Hcss, dpr);
        }
      }
      recDrawRaf = requestAnimationFrame(loop);
    }
    recDrawRaf = requestAnimationFrame(loop);
  }
  function stopCompositeDrawLoop(){
    if(recDrawRaf) cancelAnimationFrame(recDrawRaf);
    recDrawRaf = null;
  }

  async function startRecording(){
    if(!cameraStream){ log('ã‚«ãƒ¡ãƒ©é–‹å§‹å¾Œã«éŒ²ç”»ã§ãã¾ã™'); return; }
    if(isFrozen){ log('ä¸€æ™‚åœæ­¢ä¸­ã¯éŒ²ç”»ã§ãã¾ã›ã‚“'); return; }
    if(isRecording){ return; }
    if(isTlRecording){ log('TLéŒ²ç”»ä¸­ã¯å‹•ç”»éŒ²ç”»ã§ãã¾ã›ã‚“'); return; }

    // prepare composite canvas and stream
    const targetFps = Number(videoFpsInput.value)||30;
    startCompositeDrawLoop(targetFps);

    const stream = compositeCanvas.captureStream(Math.max(1, Math.min(60, targetFps)));

    // add audio if enabled
    if(audioEnabled && cameraStream.getAudioTracks().length){
      cameraStream.getAudioTracks().forEach(track=>{
        try{ stream.addTrack(track); }catch(e){}
      });
    }

    const mimeType = pickSupportedMime();
    recordChunks = [];
    try{
      recorder = new MediaRecorder(stream, mimeType? { mimeType } : undefined);
    }catch(e){
      console.error(e);
      log('éŒ²ç”»é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆMediaRecorderãŒåˆ©ç”¨ã§ããªã„å¯èƒ½æ€§ï¼‰');
      stopCompositeDrawLoop();
      return;
    }

    recorder.ondataavailable = (e)=>{
      if(e.data && e.data.size>0) recordChunks.push(e.data);
    };
    recorder.onstop = ()=>{
      stopCompositeDrawLoop();
      stopRecTimer();

      const blob = new Blob(recordChunks, { type: recorder.mimeType || 'video/webm' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const ts=new Date().toISOString().replace(/[:.]/g,'-');
      a.href = url;
      a.download = `record_${ts}.webm`;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 30000);

      log('å‹•ç”»ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼ˆWebMï¼‰');
      recordChunks = [];
      recorder = null;
      isRecording = false;

      btnStartRec.disabled = isFrozen || !cameraStream;
      btnStopRec.disabled = true;
    };

    recorder.start(200); // timeslice
    isRecording = true;
    startRecTimer();
    btnStartRec.disabled = true;
    btnStopRec.disabled = false;
    log('å‹•ç”»éŒ²ç”»ã‚’é–‹å§‹ã—ã¾ã—ãŸ');
  }

  function stopRecording(){
    if(!isRecording || !recorder) return;
    try{ recorder.stop(); }catch(e){}
    btnStopRec.disabled = true;
    log('å‹•ç”»éŒ²ç”»ã‚’åœæ­¢ã—ã¾ã—ãŸï¼ˆä¿å­˜å‡¦ç†ä¸­ï¼‰');
  }

  btnStartRec.addEventListener('click', startRecording);
  btnStopRec.addEventListener('click', stopRecording);
  btnStopRec.disabled = true;

  // ===== ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹ =====
  let isTlRecording = false;
  let tlFrames = [];
  let tlStartTs = 0;
  let tlTimerInterval = null;
  let tlIntervalHandle = null;

  function startTlTimer(){
    tlStartTs = performance.now();
    tlTimerEl.textContent = '00:00';
    if(tlTimerInterval) clearInterval(tlTimerInterval);
    tlTimerInterval = setInterval(()=>{
      tlTimerEl.textContent = fmtTime(performance.now()-tlStartTs);
    }, 250);
  }
  function stopTlTimer(){
    if(tlTimerInterval) clearInterval(tlTimerInterval);
    tlTimerInterval = null;
    tlTimerEl.textContent = '00:00';
  }

  function frameToBlob(){
    // capture composite PNG
    drawCompositeFrame();
    return new Promise((resolve)=>{
      compositeCanvas.toBlob((b)=>resolve(b), 'image/png');
    });
  }

  async function startTimelapse(){
    if(!cameraStream){ log('ã‚«ãƒ¡ãƒ©é–‹å§‹å¾Œã«TLéŒ²ç”»ã§ãã¾ã™'); return; }
    if(isFrozen){ log('ä¸€æ™‚åœæ­¢ä¸­ã¯TLéŒ²ç”»ã§ãã¾ã›ã‚“'); return; }
    if(isTlRecording){ return; }
    if(isRecording){ log('å‹•ç”»éŒ²ç”»ä¸­ã¯TLéŒ²ç”»ã§ãã¾ã›ã‚“'); return; }

    isTlRecording = true;
    tlFrames = [];
    btnStartTl.disabled = true;
    btnStopTl.disabled = false;

    startTlTimer();

    const intervalMs = Math.max(100, Number(tlIntervalInput.value)||500);

    log(`TLéŒ²ç”»ã‚’é–‹å§‹ã—ã¾ã—ãŸï¼ˆé–“éš” ${intervalMs}msï¼‰`);

    // capture immediately then interval
    const cap = async ()=>{
      if(!isTlRecording) return;
      const blob = await frameToBlob();
      if(blob) tlFrames.push(blob);
    };
    await cap();

    tlIntervalHandle = setInterval(cap, intervalMs);
  }

  async function stopTimelapse(){
    if(!isTlRecording) return;
    isTlRecording = false;
    if(tlIntervalHandle) clearInterval(tlIntervalHandle);
    tlIntervalHandle = null;
    stopTlTimer();

    btnStartTl.disabled = isFrozen || !cameraStream;
    btnStopTl.disabled = true;

    if(!tlFrames.length){
      log('TLãƒ•ãƒ¬ãƒ¼ãƒ ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
      return;
    }

    // Encode as WebM using MediaRecorder from canvas stream replay.
    // Approach: draw each stored image to temp canvas at fps, record.
    const fps = Math.max(1, Math.min(60, Number(tlFpsInput.value)||10));
    const tmp = document.createElement('canvas');
    const tctx = tmp.getContext('2d');
    const rect = cameraWrapper.getBoundingClientRect();
    const W = Math.max(2, Math.floor(rect.width));
    const H = Math.max(2, Math.floor(rect.height));
    tmp.width = W;
    tmp.height = H;

    const stream = tmp.captureStream(fps);
    const mimeType = pickSupportedMime();

    let tlRec;
    let chunks=[];
    try{
      tlRec = new MediaRecorder(stream, mimeType? { mimeType } : undefined);
    }catch(e){
      console.error(e);
      log('TLä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆMediaRecorderåˆ©ç”¨ä¸å¯ï¼‰');
      return;
    }

    tlRec.ondataavailable = (e)=>{ if(e.data && e.data.size>0) chunks.push(e.data); };
    const stopped = new Promise((resolve)=> tlRec.onstop = resolve);
    tlRec.start(200);

    // play back frames at fps
    let idx=0;
    const frameDur = 1000/fps;

    const imgs = [];
    for(const b of tlFrames){
      const url = URL.createObjectURL(b);
      const img = new Image();
      img.src = url;
      await img.decode().catch(()=>{});
      imgs.push({img,url});
    }

    await new Promise((resolve)=>{
      const timer = setInterval(()=>{
        if(idx >= imgs.length){
          clearInterval(timer);
          resolve();
          return;
        }
        const {img} = imgs[idx];
        tctx.setTransform(1,0,0,1,0,0);
        tctx.clearRect(0,0,W,H);
        // fill black
        tctx.fillStyle='black';
        tctx.fillRect(0,0,W,H);
        // draw image fit
        tctx.drawImage(img,0,0,W,H);
        idx++;
      }, frameDur);
    });

    // stop
    tlRec.stop();
    await stopped;

    imgs.forEach(o=> URL.revokeObjectURL(o.url));

    const blob = new Blob(chunks, { type: tlRec.mimeType || 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts=new Date().toISOString().replace(/[:.]/g,'-');
    a.href = url;
    a.download = `timelapse_${ts}.webm`;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 30000);

    log('ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼ˆWebMï¼‰');
    tlFrames = [];
  }

  btnStartTl.addEventListener('click', startTimelapse);
  btnStopTl.addEventListener('click', stopTimelapse);
  btnStopTl.disabled = true;

  // ===== ã‚ºãƒ¼ãƒ æ™‚ã®ãƒã‚¤ãƒ³ã‚¿åˆ¶å¾¡ =====
  // textLayer pointer default
  textLayer.style.pointerEvents = 'none';

  // ===== åˆæœŸãƒ­ã‚° =====
  log('èµ·å‹•ã—ã¾ã—ãŸã€‚ã‚«ãƒ¡ãƒ©é–‹å§‹â†’æç”»/ãƒ†ã‚­ã‚¹ãƒˆãŒä½¿ãˆã¾ã™ã€‚');
</script>
</body>
</html>
