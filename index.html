<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ã‚«ãƒ¡ãƒ©ï¼‹æ‰‹æãï¼‹ã‚ºãƒ¼ãƒ ï¼‹æ˜ åƒèª¿æ•´ï¼‹æ’®å½±</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont;
      background: #000;
      color: #fff;
    }
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 8px 12px;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 5;
      position: relative;
    }
    header span.title {
      font-weight: 600;
    }
    #header-right {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #camera-wrapper {
      position: relative;
      flex: 1;
      background: #000;
      overflow: hidden;
      touch-action: none;
    }
    #camera-inner {
      position: absolute;
      inset: 0;
      transform-origin: 0 0;
    }
    #video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #draw-layer,
    #ui-layer {
      position: absolute;
      inset: 0;
    }
    #draw-layer {
      touch-action: none;
    }
    #ui-layer {
      pointer-events: none;
    }

    /* â–¼ ä¸‹ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ï¼ˆ1è¡Œå›ºå®šãƒ»å¹…ã«å¿œã˜ã¦ã‚¢ã‚¤ã‚³ãƒ³è‡ªå‹•ç¸®å°ï¼‰ */
    #toolbar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 8px;
      transform: none;
      display: flex;
      flex-wrap: nowrap;            /* æŠ˜ã‚Šè¿”ã•ãªã„ */
      justify-content: center;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(6px);
      z-index: 20;
      max-width: 100%;
      box-sizing: border-box;
    }
    .tool-btn {
      /* ç”»é¢å¹…ã«å¿œã˜ã¦ã‚µã‚¤ã‚ºå¯å¤‰ï¼š28ã€œ40px ã®ç¯„å›²ã§è‡ªå‹•èª¿æ•´ */
      width: clamp(28px, 7vw, 40px);
      height: clamp(28px, 7vw, 40px);
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.06);
      color: #fff;
      font-size: clamp(14px, 3vw, 20px);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      flex: 0 0 auto;
    }
    .tool-btn.small {
      /* small ã‚‚åŒã˜ãƒ«ãƒ¼ãƒ«ã«ã—ã¦æƒãˆã‚„ã™ã */
      width: clamp(26px, 6.5vw, 36px);
      height: clamp(26px, 6.5vw, 36px);
      font-size: clamp(13px, 2.8vw, 18px);
    }
    .tool-btn:disabled {
      opacity: 0.35;
      cursor: default;
    }
    .tool-group-sep {
      width: 4px;
      flex: 0 0 auto;
    }
    .rec-timer {
      font-size: 11px;
      min-width: 40px;
      text-align: center;
      color: #eee;
      flex: 0 0 auto;
    }

    /* ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ‘ãƒãƒ«å…±é€š */
    .floating-panel {
      position: fixed;
      background: rgba(0,0,0,0.8);
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 11px;
      color: #eee;
      z-index: 25;
      max-width: 260px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
    }
    .floating-panel .panel-title {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 11px;
    }
    .floating-panel label {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 3px;
      white-space: nowrap;
    }
    .floating-panel input[type="number"] {
      width: 50px;
      font-size: 11px;
    }
    .floating-panel input[type="color"] {
      width: 32px;
      height: 18px;
      padding: 0;
      border: none;
      background: transparent;
    }
    .floating-panel input[type="range"] {
      width: 130px;
    }
    .floating-panel select {
      font-size: 11px;
      max-width: 150px;
    }

    /* ãƒšãƒ³ãƒ‘ãƒãƒ«ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼å´ï¼‰ */
    #pen-panel {
      top: 48px;
      right: 10px;
      display: none;
    }

    /* æ˜ åƒè¨­å®šãƒ‘ãƒãƒ«ï¼ˆå³ä¸‹ï¼‰ */
    #video-panel {
      right: 10px;
      bottom: 84px;
      display: none;
    }

    /* ãƒ˜ãƒƒãƒ€å°ãƒœã‚¿ãƒ³ */
    #log-toggle,
    #pen-toggle,
    #btn-clear {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.10);
      color: #fff;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      padding: 0;
    }
/* é»’æ¿æ¶ˆã—ã‚¢ã‚¤ã‚³ãƒ³ */
#btn-clear .eraser-icon {
  display: block;
  width: 22px;
  height: 14px;
  border-radius: 3px;
  background: linear-gradient(
    to bottom,
    #f5c37a 0 45%,   /* ä¸Šï¼šæœ¨ã®éƒ¨åˆ†ã£ã½ã„è‰² */
    #f5c37a 45% 50%, /* å¢ƒç›®å°‘ã—å¤ªã‚ */
    #365e9a 50% 100% /* ä¸‹ï¼šé’ã„ãƒ•ã‚§ãƒ«ãƒˆéƒ¨åˆ† */
  );
  box-shadow:
    0 0 0 1px rgba(0,0,0,0.25) inset,
    0 1px 0 rgba(255,255,255,0.2);
  margin-top: 2px; /* ç¸¦æ–¹å‘ã®ä½ç½®å¾®èª¿æ•´ */
}

    /* ãƒ­ã‚°ãƒ‘ãƒãƒ« */
    #log-panel {
      position: fixed;
      left: 10px;
      top: 56px;
      width: 260px;
      max-height: 50vh;
      background: rgba(0,0,0,0.8);
      border-radius: 8px;
      padding: 6px;
      font-size: 11px;
      color: #eee;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      z-index: 30;
      display: none;
    }
    #log-panel.open {
      display: block;
    }
    #log {
      max-height: 40vh;
      overflow-y: auto;
      white-space: pre-line;
    }

    /* ã‚ºãƒ¼ãƒ é¸æŠä¸­ã®æ¡ˆå†…ãƒ†ã‚­ã‚¹ãƒˆ */
    #zoom-hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: #fff;
      z-index: 25;
      display: none;
      pointer-events: none;
    }
    #zoom-hint.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <span class="title">ã‚«ãƒ¡ãƒ©ï¼‹æ‰‹æãï¼‹ã‚ºãƒ¼ãƒ ï¼‹æ˜ åƒèª¿æ•´ï¼‹é™æ­¢ç”»ï¼å‹•ç”»ï¼TL</span>
      <div id="header-right">
        <button id="pen-toggle" title="æ‰‹æãè¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º">âœï¸</button>
<button id="btn-clear" title="æ‰‹æãã‚¯ãƒªã‚¢">
  <span class="eraser-icon" aria-hidden="true"></span>
</button>
        <button id="log-toggle" title="ãƒ­ã‚°è¡¨ç¤ºï¼éè¡¨ç¤º">â„¹ï¸</button>
      </div>
    </header>

    <div id="camera-wrapper">
      <div id="camera-inner">
        <video id="video" autoplay playsinline></video>
        <canvas id="draw-layer"></canvas>
        <canvas id="ui-layer"></canvas>
      </div>
    </div>

    <!-- ä¸‹ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
    <div id="toolbar">
      <!-- ã‚«ãƒ¡ãƒ© -->
      <button id="btn-start-camera" class="tool-btn" title="ã‚«ãƒ¡ãƒ©é–‹å§‹">ğŸ¦</button>

      <div class="tool-group-sep"></div>

      <!-- é™æ­¢ç”» -->
      <button id="btn-shot" class="tool-btn" title="å†™çœŸæ’®å½±ï¼ˆPNGï¼‰" disabled>ğŸ“·</button>

      <div class="tool-group-sep"></div>

      <!-- é€šå¸¸å‹•ç”» -->
      <button id="btn-start-rec" class="tool-btn small" title="å‹•ç”»éŒ²ç”»é–‹å§‹" disabled>âº</button>
      <button id="btn-stop-rec" class="tool-btn small" title="å‹•ç”»éŒ²ç”»åœæ­¢" disabled>â¹</button>
      <span id="rec-timer" class="rec-timer">00:00</span>

      <div class="tool-group-sep"></div>

      <!-- ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹ -->
      <button id="btn-start-tl" class="tool-btn small" title="TLéŒ²ç”»é–‹å§‹" disabled>â±</button>
      <button id="btn-stop-tl" class="tool-btn small" title="TLéŒ²ç”»åœæ­¢" disabled>â¹</button>
      <span id="tl-timer" class="rec-timer">00:00</span>

      <div class="tool-group-sep"></div>

      <!-- ã‚ºãƒ¼ãƒ  -->
      <button id="btn-zoom-select" class="tool-btn small" title="ã‚ºãƒ¼ãƒ é ˜åŸŸã‚’é¸æŠ">ğŸ”</button>
      <button id="btn-zoom-reset" class="tool-btn small" title="ã‚ºãƒ¼ãƒ è§£é™¤">ğŸ”</button>

      <div class="tool-group-sep" style="width:8px;"></div>

      <!-- æ˜ åƒè¨­å®šã‚¢ã‚¤ã‚³ãƒ³ -->
      <button id="video-settings-toggle" class="tool-btn small" title="æ˜ åƒè¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º">ğŸš</button>
    </div>

    <!-- æ‰‹æãè¨­å®šãƒ‘ãƒãƒ« -->
    <div id="pen-panel" class="floating-panel">
      <div class="panel-title">æ‰‹æãè¨­å®š</div>
      <label>è‰²
        <input type="color" id="pen-color" value="#ff0000">
      </label>
      <label>å¤ªã•
        <input type="number" id="pen-size" min="1" max="40" value="5">
      </label>
    </div>

    <!-- æ˜ åƒï¼‹éŒ²ç”»è¨­å®šãƒ‘ãƒãƒ« -->
    <div id="video-panel" class="floating-panel">
      <div class="panel-title">éŒ²ç”»ï¼ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹è¨­å®š</div>
      <label>å‹•ç”»FPS
        <input type="number" id="video-fps" min="1" max="60" value="30">
      </label>
      <label>TL-FPS
        <input type="number" id="tl-fps" min="1" max="60" value="10">
      </label>
      <label>TLé–“éš”(ms)
        <input type="number" id="tl-interval" min="100" value="500">
      </label>

      <div class="panel-title" style="margin-top:4px;">æ˜ åƒè¨­å®š</div>
      <label>æ˜ã‚‹ã•
        <input id="brightness" type="range" min="0.2" max="2" step="0.01" value="1">
      </label>
      <label>ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ
        <input id="contrast" type="range" min="0.5" max="2" step="0.01" value="1">
      </label>
      <label>éœ²å‡º
        <input id="exposure" type="range" min="-2" max="2" step="0.1" value="0">
      </label>
      <label>è‰²æ¸©åº¦
        <input id="color-temp" type="range" min="-1" max="1" step="0.1" value="0">
      </label>
      <label>ã‚·ãƒ£ãƒ¼ãƒ—
        <input id="sharpness" type="range" min="0" max="1" step="0.1" value="0">
      </label>
      <label>
        <input id="line-boost" type="checkbox">
        ç·šãƒ»æ–‡å­—ãã£ãã‚Š
      </label>
      <label>
        <input id="noise-reduce" type="checkbox">
        ãƒã‚¤ã‚ºè»½æ¸›ï¼ˆã‚ºãƒ¼ãƒ æ™‚ã®ã‚‚ã‚„ã‚‚ã‚„æŠ‘åˆ¶ï¼‰
      </label>

      <div class="panel-title" style="margin-top:4px;">è¡¨ç¤ºåè»¢</div>
      <label>
        <input id="flip-h" type="checkbox" checked>
        å·¦å³åè»¢ï¼ˆãƒŸãƒ©ãƒ¼ï¼‰
      </label>
      <label>
        <input id="flip-v" type="checkbox">
        ä¸Šä¸‹åè»¢
      </label>

      <div class="panel-title" style="margin-top:4px;">ã‚«ãƒ¡ãƒ©é¸æŠ</div>
      <label>ã‚«ãƒ¡ãƒ©
        <select id="camera-select" disabled></select>
      </label>

      <div class="panel-title" style="margin-top:4px;">éŸ³å£°</div>
      <label>
        <input id="audio-enabled" type="checkbox">
        å‹•ç”»ã«ãƒã‚¤ã‚¯éŸ³å£°ã‚’å…¥ã‚Œã‚‹
      </label>
      <div style="margin-top:3px;color:#ccc;">
        â€»ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯éŸ³å£°OFFã§ã™ã€‚<br>
        â€»ã€Œç·šãƒ»æ–‡å­—ãã£ãã‚Šã€ã€Œãƒã‚¤ã‚ºè»½æ¸›ã€ã¯ä¸»ã«ä¿å­˜ç”»åƒï¼éŒ²ç”»å‹•ç”»ã«åæ˜ ã•ã‚Œã¾ã™ã€‚<br>
        â€»ãƒ–ãƒ©ã‚¦ã‚¶éŒ²ç”»ã¯ WebM å½¢å¼ã§ä¿å­˜ã•ã‚Œã¾ã™ã€‚mp4/mov ãŒå¿…è¦ãªå ´åˆã¯å¤–éƒ¨ãƒ„ãƒ¼ãƒ«ã§å¤‰æ›ã—ã¦ãã ã•ã„ã€‚
      </div>
    </div>

    <!-- ãƒ­ã‚°ãƒ‘ãƒãƒ« -->
    <div id="log-panel">
      <div style="font-weight:600;margin-bottom:4px;">ãƒ­ã‚°</div>
      <div id="log"></div>
      <div style="margin-top:4px;color:#ccc;">
        â€»ã‚ºãƒ¼ãƒ æ™‚ã¯ã€éŒ²ç”»ãƒ»TLã‚‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨åŒã˜è¦‹ãˆæ–¹ã§ä¿å­˜ã—ã¾ã™ã€‚<br>
        â€»ã€Œç·šãƒ»æ–‡å­—ãã£ãã‚Šã€ã¯ãƒãƒ¼ãƒˆã‚„ãƒ—ãƒªãƒ³ãƒˆæ’®å½±å‘ãã§ã™ã€‚
      </div>
    </div>

    <!-- ã‚ºãƒ¼ãƒ é¸æŠä¸­ã®ãƒ’ãƒ³ãƒˆ -->
    <div id="zoom-hint">ã‚ºãƒ¼ãƒ ã—ãŸã„ç¯„å›²ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆæŒ‡ï¼ãƒšãƒ³ï¼ãƒã‚¦ã‚¹ï¼‰</div>
  </div>

  <script>
    /* ã“ã“ã‹ã‚‰ä¸‹ã¯å‰å›ç‰ˆã¨åŒã˜ JSï¼ˆéŒ²ç”»ï¼ã‚ºãƒ¼ãƒ ï¼è£œæ­£ãªã©ï¼‰ã§ã™ */
    const video = document.getElementById('video');
    const drawCanvas = document.getElementById('draw-layer');
    const drawCtx = drawCanvas.getContext('2d');
    const uiCanvas = document.getElementById('ui-layer');
    const uiCtx = uiCanvas.getContext('2d');
    const cameraWrapper = document.getElementById('camera-wrapper');
    const cameraInner = document.getElementById('camera-inner');

    const btnStartCamera = document.getElementById('btn-start-camera');
    const btnClear = document.getElementById('btn-clear');
    const btnShot = document.getElementById('btn-shot');
    const btnStartRec = document.getElementById('btn-start-rec');
    const btnStopRec = document.getElementById('btn-stop-rec');
    const btnStartTl = document.getElementById('btn-start-tl');
    const btnStopTl = document.getElementById('btn-stop-tl');
    const btnZoomSelect = document.getElementById('btn-zoom-select');
    const btnZoomReset = document.getElementById('btn-zoom-reset');
    const videoSettingsToggle = document.getElementById('video-settings-toggle');

    const penToggle = document.getElementById('pen-toggle');
    const penPanel = document.getElementById('pen-panel');
    const videoPanel = document.getElementById('video-panel');

    const penColorInput = document.getElementById('pen-color');
    const penSizeInput = document.getElementById('pen-size');
    const videoFpsInput = document.getElementById('video-fps');
    const tlFpsInput = document.getElementById('tl-fps');
    const tlIntervalInput = document.getElementById('tl-interval');

    const brightnessSlider = document.getElementById('brightness');
    const contrastSlider = document.getElementById('contrast');
    const exposureSlider = document.getElementById('exposure');
    const colorTempSlider = document.getElementById('color-temp');
    const sharpnessSlider = document.getElementById('sharpness');
    const lineBoostCheckbox = document.getElementById('line-boost');
    const noiseReduceCheckbox = document.getElementById('noise-reduce');
    const flipHCheckbox = document.getElementById('flip-h');
    const flipVCheckbox = document.getElementById('flip-v');
    const audioEnabledCheckbox = document.getElementById('audio-enabled');
    const cameraSelect = document.getElementById('camera-select');

    const logEl = document.getElementById('log');
    const logPanel = document.getElementById('log-panel');
    const logToggle = document.getElementById('log-toggle');
    const zoomHint = document.getElementById('zoom-hint');

    const recTimerEl = document.getElementById('rec-timer');
    const tlTimerEl = document.getElementById('tl-timer');

    let cameraStream = null;
    let currentVideoDeviceId = null;
    let hasInitializedCamera = false;

    const compositeCanvas = document.createElement('canvas');
    const compositeCtx = compositeCanvas.getContext('2d');

    const supportsMediaRecorder = typeof MediaRecorder !== 'undefined';
    let supportsCaptureStream = false;
    try {
      supportsCaptureStream = typeof compositeCanvas.captureStream === 'function';
    } catch (e) {
      supportsCaptureStream = false;
    }

    drawCtx.imageSmoothingEnabled = false;
    uiCtx.imageSmoothingEnabled = false;
    compositeCtx.imageSmoothingEnabled = false;

    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    let recorder = null;
    let recordedChunks = [];
    let recordingMode = null;
    let animationId = null;
    let lastTlTime = 0;
    let tlIntervalMs = 500;

    let recStartTime = null;
    let tlStartTime = null;
    let recTimerId = null;
    let tlTimerId = null;

    let zoomMode = false;
    let zoomRect = null;
    let zoomDragStart = null;
    let lastZoomPos = null;

    const settings = {
      brightness: 1,
      contrast: 1,
      exposure: 0,
      colorTemp: 0,
      sharpness: 0,
      lineBoost: false,
      noiseReduce: false
    };
    let videoFilterString = 'brightness(1) contrast(1)';
    let flipH = true;
    let flipV = false;

    let audioEnabled = false;
    audioEnabledCheckbox.checked = false;

    function log(msg) {
      const now = new Date();
      const time = now.toLocaleTimeString();
      logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
    }

    if (!supportsMediaRecorder || !supportsCaptureStream) {
      log('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯éŒ²ç”»ï¼ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹æ©Ÿèƒ½ãŒå®Œå…¨ã«ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼ˆé™æ­¢ç”»ã¯åˆ©ç”¨å¯èƒ½ï¼‰ã€‚');
    }

    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const m = Math.floor(totalSec / 60);
      const s = totalSec % 60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function startRecTimer() {
      recStartTime = Date.now();
      recTimerEl.textContent = '00:00';
      if (recTimerId) clearInterval(recTimerId);
      recTimerId = setInterval(() => {
        recTimerEl.textContent = formatTime(Date.now() - recStartTime);
      }, 500);
    }
    function stopRecTimer() {
      if (recTimerId) {
        clearInterval(recTimerId);
        recTimerId = null;
      }
    }
    function startTlTimer() {
      tlStartTime = Date.now();
      tlTimerEl.textContent = '00:00';
      if (tlTimerId) clearInterval(tlTimerId);
      tlTimerId = setInterval(() => {
        tlTimerEl.textContent = formatTime(Date.now() - tlStartTime);
      }, 500);
    }
    function stopTlTimer() {
      if (tlTimerId) {
        clearInterval(tlTimerId);
        tlTimerId = null;
      }
    }

    logToggle.addEventListener('click', () => {
      logPanel.classList.toggle('open');
    });
    penToggle.addEventListener('click', () => {
      penPanel.style.display = penPanel.style.display === 'block' ? 'none' : 'block';
    });
    videoSettingsToggle.addEventListener('click', () => {
      videoPanel.style.display = videoPanel.style.display === 'block' ? 'none' : 'block';
    });

    audioEnabledCheckbox.addEventListener('change', () => {
      audioEnabled = audioEnabledCheckbox.checked;
      log(`éŸ³å£°éŒ²éŸ³: ${audioEnabled ? 'ON' : 'OFF'}`);
      if (cameraStream) {
        cameraStream.getAudioTracks().forEach(t => {
          t.enabled = audioEnabled;
        });
      }
    });

    async function populateCameraList() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        cameraSelect.innerHTML = '';

        videoDevices.forEach((d, idx) => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `ã‚«ãƒ¡ãƒ© ${idx + 1}`;
          cameraSelect.appendChild(opt);
        });

        if (!currentVideoDeviceId && videoDevices[0]) {
          currentVideoDeviceId = videoDevices[0].deviceId;
        }
        if (currentVideoDeviceId) {
          cameraSelect.value = currentVideoDeviceId;
        }

        cameraSelect.disabled = videoDevices.length <= 1;
        if (videoDevices.length > 1) {
          log(`ã‚«ãƒ¡ãƒ©ã‚’ ${videoDevices.length} å°æ¤œå‡ºã—ã¾ã—ãŸã€‚æ˜ åƒè¨­å®šã‹ã‚‰åˆ‡ã‚Šæ›¿ãˆã§ãã¾ã™ã€‚`);
        }
      } catch (e) {
        console.log('enumerateDevices error', e);
      }
    }

    async function initCamera(deviceId = null) {
      try {
        if (cameraStream) {
          cameraStream.getTracks().forEach(t => t.stop());
        }

        const constraints = {
          video: deviceId
            ? { deviceId: { exact: deviceId }, width: { ideal: 1920 }, height: { ideal: 1080 } }
            : { width: { ideal: 1920 }, height: { ideal: 1080 } },
          audio: true
        };

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraStream = stream;
        hasInitializedCamera = true;

        cameraStream.getAudioTracks().forEach(t => { t.enabled = audioEnabled; });

        video.srcObject = cameraStream;
        log(deviceId ? 'ã‚«ãƒ¡ãƒ©ã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ' : 'ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¾ã—ãŸ');

        video.addEventListener('loadedmetadata', () => {
          resizeCanvases();
          btnShot.disabled = false;
          if (supportsMediaRecorder && supportsCaptureStream) {
            btnStartRec.disabled = false;
            btnStartTl.disabled = false;
          } else {
            btnStartRec.disabled = true;
            btnStopRec.disabled = true;
            btnStartTl.disabled = true;
            btnStopTl.disabled = true;
          }
        }, { once: true });

        btnStartCamera.disabled = true;

        await populateCameraList();
      } catch (e) {
        console.error(e);
        log('ã‚«ãƒ¡ãƒ©ãŒè¨±å¯ã•ã‚Œãªã‹ã£ãŸã‹ã€é¸æŠã—ãŸã‚«ãƒ¡ãƒ©ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã§ã—ãŸ');
      }
    }

    btnStartCamera.addEventListener('click', () => {
      initCamera(currentVideoDeviceId);
    });

    cameraSelect.addEventListener('change', () => {
      const devId = cameraSelect.value;
      currentVideoDeviceId = devId;
      if (hasInitializedCamera) {
        initCamera(devId);
      }
    });

    function resizeCanvases() {
      const rect = cameraWrapper.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      const dpr = window.devicePixelRatio || 1;

      [drawCanvas, uiCanvas, compositeCanvas].forEach(c => {
        c.width = width * dpr;
        c.height = height * dpr;
        c.style.width = width + 'px';
        c.style.height = height + 'px';
      });

      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);

      zoomRect = null;
      updateZoomTransform();

      log(`ã‚­ãƒ£ãƒ³ãƒã‚¹: ${width}x${height} (DPR=${dpr} â†’ å†…éƒ¨ ${drawCanvas.width}x${drawCanvas.height})`);
    }

    window.addEventListener('resize', () => {
      if (video.videoWidth) resizeCanvases();
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        window.scrollTo(0, 0);
        if (video.videoWidth) resizeCanvases();
      }, 200);
    });

    function getCanvasPos(e) {
      const rect = drawCanvas.getBoundingClientRect();
      let clientX, clientY;
      if (e.touches && e.touches[0]) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      const x = (clientX - rect.left) * (drawCanvas.width / rect.width);
      const y = (clientY - rect.top) * (drawCanvas.height / rect.height);
      return { x, y };
    }

    function startDraw(e) {
      if (zoomMode) return;
      e.preventDefault();
      isDrawing = true;
      const pos = getCanvasPos(e);
      lastX = pos.x;
      lastY = pos.y;
    }

    function draw(e) {
      if (!isDrawing || zoomMode) return;
      e.preventDefault();
      const pos = getCanvasPos(e);
      drawCtx.strokeStyle = penColorInput.value;
      drawCtx.lineWidth = Number(penSizeInput.value) || 3;
      drawCtx.lineCap = 'round';
      drawCtx.lineJoin = 'round';

      drawCtx.beginPath();
      drawCtx.moveTo(lastX, lastY);
      drawCtx.lineTo(pos.x, pos.y);
      drawCtx.stroke();

      lastX = pos.x;
      lastY = pos.y;
    }

    function endDraw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false;
    }

    drawCanvas.addEventListener('mousedown', startDraw);
    drawCanvas.addEventListener('mousemove', draw);
    drawCanvas.addEventListener('mouseup', endDraw);
    drawCanvas.addEventListener('mouseleave', endDraw);

    drawCanvas.addEventListener('touchstart', startDraw, { passive: false });
    drawCanvas.addEventListener('touchmove', draw, { passive: false });
    drawCanvas.addEventListener('touchend', endDraw, { passive: false });
    drawCanvas.addEventListener('touchcancel', endDraw, { passive: false });

    btnClear.addEventListener('click', () => {
      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      log('æ‰‹æããƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
    });

    function updateVideoFilter() {
      const exposureFactor = Math.pow(2, settings.exposure);
      const b = settings.brightness * exposureFactor;
      const c = settings.contrast;
      const t = settings.colorTemp;

      let filter = `brightness(${b}) contrast(${c})`;
      if (t > 0) {
        const amt = t;
        filter += ` sepia(${amt}) saturate(${1 + 0.5 * amt}) hue-rotate(-10deg)`;
      } else if (t < 0) {
        const amt = -t;
        filter += ` saturate(${1 - 0.3 * amt}) hue-rotate(${amt * 20}deg)`;
      }
      videoFilterString = filter;
      video.style.filter = filter;
    }

    function updateVideoFlipPreview() {
      const sx = flipH ? -1 : 1;
      const sy = flipV ? -1 : 1;
      video.style.transform = `scaleX(${sx}) scaleY(${sy})`;
    }

    brightnessSlider.addEventListener('input', () => {
      settings.brightness = parseFloat(brightnessSlider.value) || 1;
      updateVideoFilter();
    });
    contrastSlider.addEventListener('input', () => {
      settings.contrast = parseFloat(contrastSlider.value) || 1;
      updateVideoFilter();
    });
    exposureSlider.addEventListener('input', () => {
      settings.exposure = parseFloat(exposureSlider.value) || 0;
      updateVideoFilter();
    });
    colorTempSlider.addEventListener('input', () => {
      settings.colorTemp = parseFloat(colorTempSlider.value) || 0;
      updateVideoFilter();
    });
    sharpnessSlider.addEventListener('input', () => {
      settings.sharpness = parseFloat(sharpnessSlider.value) || 0;
    });
    lineBoostCheckbox.addEventListener('change', () => {
      settings.lineBoost = lineBoostCheckbox.checked;
      log(`ç·šãƒ»æ–‡å­—ãã£ãã‚Š: ${settings.lineBoost ? 'ON' : 'OFF'}`);
    });
    noiseReduceCheckbox.addEventListener('change', () => {
      settings.noiseReduce = noiseReduceCheckbox.checked;
      log(`ãƒã‚¤ã‚ºè»½æ¸›: ${settings.noiseReduce ? 'ON' : 'OFF'}`);
    });
    flipHCheckbox.addEventListener('change', () => {
      flipH = flipHCheckbox.checked;
      updateVideoFlipPreview();
      log(`å·¦å³åè»¢: ${flipH ? 'ON' : 'OFF'}`);
    });
    flipVCheckbox.addEventListener('change', () => {
      flipV = flipVCheckbox.checked;
      updateVideoFlipPreview();
      log(`ä¸Šä¸‹åè»¢: ${flipV ? 'ON' : 'OFF'}`);
    });

    updateVideoFilter();
    updateVideoFlipPreview();

    function applyDenoiseToImage(img, strength) {
      if (strength <= 0) return;
      const w = img.width;
      const h = img.height;
      const data = img.data;
      const src = new Uint8ClampedArray(data);

      const k = strength;
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const idx = (y * w + x) * 4;
          let r = 0, g = 0, b = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx2 = ((y + ky) * w + (x + kx)) * 4;
              r += src[idx2];
              g += src[idx2 + 1];
              b += src[idx2 + 2];
            }
          }
          const blurR = r / 9;
          const blurG = g / 9;
          const blurB = b / 9;
          const origR = src[idx];
          const origG = src[idx + 1];
          const origB = src[idx + 2];

          data[idx]     = Math.max(0, Math.min(255, origR * (1-k) + blurR * k));
          data[idx + 1] = Math.max(0, Math.min(255, origG * (1-k) + blurG * k));
          data[idx + 2] = Math.max(0, Math.min(255, origB * (1-k) + blurB * k));
        }
      }
    }

    function applySharpenToImage(img, amount, lineBoost) {
      if (amount <= 0) return;
      const w = img.width;
      const h = img.height;
      const data = img.data;
      const src = new Uint8ClampedArray(data);

      const centerBase = lineBoost ? 10 : 5;
      const gain = lineBoost ? 10 : 4;
      const center = centerBase + gain * amount;

      const kernel = [
        0, -1, 0,
        -1, center, -1,
        0, -1, 0
      ];

      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const idx = (y * w + x) * 4;
          let r = 0, g = 0, b = 0;
          let ki = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx2 = ((y + ky) * w + (x + kx)) * 4;
              const wgt = kernel[ki++];
              r += src[idx2] * wgt;
              g += src[idx2 + 1] * wgt;
              b += src[idx2 + 2] * wgt;
            }
          }
          data[idx]     = Math.max(0, Math.min(255, r));
          data[idx + 1] = Math.max(0, Math.min(255, g));
          data[idx + 2] = Math.max(0, Math.min(255, b));
        }
      }

      if (lineBoost) {
        const contrast = 1.4 + 0.6 * amount;
        for (let i = 0; i < data.length; i += 4) {
          let r = data[i], g = data[i+1], b = data[i+2];
          const yLum = 0.299*r + 0.587*g + 0.114*b;
          const y2 = 128 + (yLum - 128) * contrast;
          const ratio = yLum > 0 ? (y2 / yLum) : 1;
          data[i]   = Math.max(0, Math.min(255, r * ratio));
          data[i+1] = Math.max(0, Math.min(255, g * ratio));
          data[i+2] = Math.max(0, Math.min(255, b * ratio));
        }
      }
    }

    function postProcessFrame() {
      const w = compositeCanvas.width;
      const h = compositeCanvas.height;
      if (!w || !h) return;

      const needDenoise = settings.noiseReduce;
      const sharpFromSlider = settings.sharpness;
      const extraFromLine = settings.lineBoost ? 0.8 : 0;
      const sharpAmount = Math.min(1.5, Math.max(0, sharpFromSlider + extraFromLine));

      if (!needDenoise && sharpAmount <= 0) return;

      const img = compositeCtx.getImageData(0, 0, w, h);

      if (needDenoise) {
        applyDenoiseToImage(img, 0.7);
      }
      if (sharpAmount > 0) {
        applySharpenToImage(img, sharpAmount, settings.lineBoost);
      }

      compositeCtx.putImageData(img, 0, 0);
    }

    function drawCompositeFrame() {
      const w = compositeCanvas.width;
      const h = compositeCanvas.height;
      if (!w || !h) return;
      if (!video.videoWidth || !video.videoHeight) return;

      const Wcss = cameraWrapper.clientWidth;
      const Hcss = cameraWrapper.clientHeight;
      if (!Wcss || !Hcss) return;

      const dpr = window.devicePixelRatio || 1;
      const vw = video.videoWidth;
      const vh = video.videoHeight;

      compositeCtx.save();
      compositeCtx.setTransform(1, 0, 0, 1, 0, 0);
      compositeCtx.fillStyle = 'black';
      compositeCtx.fillRect(0, 0, w, h);

      compositeCtx.scale(dpr, dpr);

      let s = 1;
      let tx = 0;
      let ty = 0;

      if (zoomRect) {
        const r = zoomRect;
        const sZoom = Math.max(Wcss / r.w, Hcss / r.h);
        const cx = r.x + r.w / 2;
        const cy = r.y + r.h / 2;
        const CwX = Wcss / 2;
        const CwY = Hcss / 2;
        const ttx = CwX - sZoom * cx;
        const tty = CwY - sZoom * cy;
        s = sZoom;
        tx = ttx;
        ty = tty;
      }

      compositeCtx.translate(tx, ty);
      compositeCtx.scale(s, s);

      const s0 = Math.max(Wcss / vw, Hcss / vh);
      const vsW = vw * s0;
      const vsH = vh * s0;
      const dx = (Wcss - vsW) / 2;
      const dy = (Hcss - vsH) / 2;

      compositeCtx.save();
      compositeCtx.filter = videoFilterString || 'none';

      let drawTx = dx;
      let drawTy = dy;
      let scaleX = 1;
      let scaleY = 1;
      if (flipH) {
        drawTx = dx + vsW;
        scaleX = -1;
      }
      if (flipV) {
        drawTy = dy + vsH;
        scaleY = -1;
      }

      compositeCtx.translate(drawTx, drawTy);
      compositeCtx.scale(scaleX, scaleY);
      compositeCtx.scale(s0, s0);

      compositeCtx.drawImage(video, 0, 0, vw, vh);

      compositeCtx.restore();

      compositeCtx.drawImage(
        drawCanvas,
        0, 0, drawCanvas.width, drawCanvas.height,
        0, 0, Wcss, Hcss
      );

      compositeCtx.restore();

      postProcessFrame();
    }

    btnShot.addEventListener('click', () => {
      drawCompositeFrame();
      const url = compositeCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.href = url;
      a.download = `snapshot_${ts}.png`;
      a.click();
      log('é™æ­¢ç”»ã‚’PNGã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸï¼ˆæ˜ åƒè¨­å®šãƒ»åè»¢ãƒ»ã‚ºãƒ¼ãƒ ãƒ»ãƒã‚¤ã‚ºè»½æ¸›ãƒ»ç·šãã£ãã‚Šåæ˜ ï¼‰');
    });

    btnStartRec.addEventListener('click', () => {
      if (!cameraStream) {
        log('å…ˆã«ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¦ãã ã•ã„');
        return;
      }
      if (!supportsMediaRecorder || !supportsCaptureStream) {
        log('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯éŒ²ç”»æ©Ÿèƒ½ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆiPhone Safari ã®ä¸€éƒ¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãªã©ï¼‰ã€‚é™æ­¢ç”»ã¯åˆ©ç”¨å¯èƒ½ã§ã™ã€‚');
        return;
      }

      const fps = Number(videoFpsInput.value) || 30;
      const stream = compositeCanvas.captureStream(fps);

      if (audioEnabled && cameraStream) {
        cameraStream.getAudioTracks().forEach(t => {
          t.enabled = true;
          stream.addTrack(t);
        });
      } else if (cameraStream) {
        cameraStream.getAudioTracks().forEach(t => t.enabled = false);
      }

      recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      recordedChunks = [];
      recordingMode = 'normal';

      recorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      recorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `record_normal_${ts}.webm`;
        a.click();
        log(`é€šå¸¸å‹•ç”»(WebM, éŸ³å£°${audioEnabled ? 'ã‚ã‚Š' : 'ãªã—'})ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
      };

      const render = () => {
        drawCompositeFrame();
        animationId = requestAnimationFrame(render);
      };
      render();

      recorder.start();
      btnStartRec.disabled = true;
      btnStopRec.disabled = false;
      btnStartTl.disabled = true;
      startRecTimer();
      log(`é€šå¸¸éŒ²ç”»é–‹å§‹ (FPS: ${fps}, ã‚ºãƒ¼ãƒ : ${zoomRect ? 'ON' : 'OFF'}, éŸ³å£°${audioEnabled ? 'ON' : 'OFF'})`);
    });

    btnStopRec.addEventListener('click', () => {
      if (!recorder || recordingMode !== 'normal') return;
      recorder.stop();
      cancelAnimationFrame(animationId);
      animationId = null;
      btnStartRec.disabled = false;
      btnStopRec.disabled = true;
      btnStartTl.disabled = false;
      stopRecTimer();
      log('é€šå¸¸éŒ²ç”»åœæ­¢');
    });

    btnStartTl.addEventListener('click', () => {
      if (!cameraStream) {
        log('å…ˆã«ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¦ãã ã•ã„');
        return;
      }
      if (!supportsMediaRecorder || !supportsCaptureStream) {
        log('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹éŒ²ç”»ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆiPhone Safari ã®ä¸€éƒ¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãªã©ï¼‰ã€‚é™æ­¢ç”»ã¯åˆ©ç”¨å¯èƒ½ã§ã™ã€‚');
        return;
      }

      const fps = Number(tlFpsInput.value) || 10;
      tlIntervalMs = Number(tlIntervalInput.value) || 500;

      const stream = compositeCanvas.captureStream(fps);

      if (audioEnabled && cameraStream) {
        cameraStream.getAudioTracks().forEach(t => {
          t.enabled = true;
          stream.addTrack(t);
        });
      } else if (cameraStream) {
        cameraStream.getAudioTracks().forEach(t => t.enabled = false);
      }

      recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      recordedChunks = [];
      recordingMode = 'timelapse';
      lastTlTime = performance.now();

      recorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      recorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `record_timelapse_${ts}.webm`;
        a.click();
        log(`ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹(WebM, éŸ³å£°${audioEnabled ? 'ã‚ã‚Š' : 'ãªã—'})ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
      };

      const renderTl = (time) => {
        if (time - lastTlTime >= tlIntervalMs) {
          drawCompositeFrame();
          lastTlTime = time;
        }
        animationId = requestAnimationFrame(renderTl);
      };
      animationId = requestAnimationFrame(renderTl);

      recorder.start();
      btnStartTl.disabled = true;
      btnStopTl.disabled = false;
      btnStartRec.disabled = true;
      startTlTimer();
      log(`ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹éŒ²ç”»é–‹å§‹ (éŒ²ç”»FPS: ${fps}, é–“éš”: ${tlIntervalMs}ms, ã‚ºãƒ¼ãƒ : ${zoomRect ? 'ON' : 'OFF'}, éŸ³å£°${audioEnabled ? 'ON' : 'OFF'})`);
    });

    btnStopTl.addEventListener('click', () => {
      if (!recorder || recordingMode !== 'timelapse') return;
      recorder.stop();
      cancelAnimationFrame(animationId);
      animationId = null;
      btnStartTl.disabled = false;
      btnStopTl.disabled = true;
      btnStartRec.disabled = false;
      stopTlTimer();
      log('ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹éŒ²ç”»åœæ­¢');
    });

    function updateZoomTransform() {
      if (!zoomRect) {
        cameraInner.style.transform = 'translate(0px, 0px) scale(1)';
        return;
      }
      const W = cameraWrapper.clientWidth;
      const H = cameraWrapper.clientHeight;
      if (!W || !H) return;

      const r = zoomRect;
      const s = Math.max(W / r.w, H / r.h);

      const cx = r.x + r.w / 2;
      const cy = r.y + r.h / 2;
      const CwX = W / 2;
      const CwY = H / 2;

      const tx = CwX - s * cx;
      const ty = CwY - s * cy;

      cameraInner.style.transform = `translate(${tx}px, ${ty}px) scale(${s})`;
    }

    function getWrapperPosFromClient(clientX, clientY) {
      const rect = cameraWrapper.getBoundingClientRect();
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    function clearUiCanvas() {
      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
    }

    function enterZoomMode() {
      zoomMode = true;
      zoomDragStart = null;
      lastZoomPos = null;
      clearUiCanvas();
      zoomHint.classList.add('visible');
      drawCanvas.style.pointerEvents = 'none';
      log('ã‚ºãƒ¼ãƒ é ˜åŸŸé¸æŠãƒ¢ãƒ¼ãƒ‰ï¼šæ˜ åƒä¸Šã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãã ã•ã„');
    }

    function exitZoomMode() {
      zoomMode = false;
      zoomDragStart = null;
      lastZoomPos = null;
      clearUiCanvas();
      zoomHint.classList.remove('visible');
      drawCanvas.style.pointerEvents = 'auto';
    }

    btnZoomSelect.addEventListener('click', () => {
      if (!video.videoWidth) {
        log('ã‚«ãƒ¡ãƒ©èµ·å‹•å¾Œã«ã‚ºãƒ¼ãƒ ã§ãã¾ã™');
        return;
      }
      enterZoomMode();
    });

    btnZoomReset.addEventListener('click', () => {
      zoomRect = null;
      updateZoomTransform();
      exitZoomMode();
      log('ã‚ºãƒ¼ãƒ ã‚’è§£é™¤ã—ã¾ã—ãŸ');
    });

    function drawZoomRectPreview(currentPos) {
      const start = zoomDragStart;
      clearUiCanvas();
      uiCtx.strokeStyle = '#00ff88';
      uiCtx.lineWidth = 2;
      uiCtx.setLineDash([6, 4]);

      const rect = cameraWrapper.getBoundingClientRect();
      const scaleX = uiCanvas.width / rect.width;
      const scaleY = uiCanvas.height / rect.height;

      const x = Math.min(start.x, currentPos.x) * scaleX;
      const y = Math.min(start.y, currentPos.y) * scaleY;
      const w = Math.abs(currentPos.x - start.x) * scaleX;
      const h = Math.abs(currentPos.y - start.y) * scaleY;

      uiCtx.strokeRect(x, y, w, h);
      uiCtx.setLineDash([]);
    }

    function finalizeZoom(endPosMaybe) {
      const endPos = endPosMaybe || lastZoomPos || zoomDragStart;
      if (!zoomDragStart || !endPos) {
        clearUiCanvas();
        log('ã‚ºãƒ¼ãƒ ç¯„å›²ãŒæ±ºå®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãã ã•ã„ã€‚');
        return;
      }

      const x0 = zoomDragStart.x;
      const y0 = zoomDragStart.y;
      const x1 = endPos.x;
      const y1 = endPos.y;
      const rx = Math.min(x0, x1);
      const ry = Math.min(y0, y1);
      const rw = Math.abs(x1 - x0);
      const rh = Math.abs(y1 - y0);

      const minSize = 20;
      if (rw < minSize || rh < minSize) {
        clearUiCanvas();
        log('é¸æŠç¯„å›²ãŒå°ã•ã™ãã¾ã™ã€‚ã‚‚ã†ä¸€åº¦åºƒã‚ã«ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãã ã•ã„ã€‚');
        return;
      }

      const W = cameraWrapper.clientWidth;
      const H = cameraWrapper.clientHeight;
      const rxClamped = Math.max(0, Math.min(rx, W));
      const ryClamped = Math.max(0, Math.min(ry, H));
      const rwClamped = Math.min(rw, W - rxClamped);
      const rhClamped = Math.min(rh, H - ryClamped);

      zoomRect = { x: rxClamped, y: ryClamped, w: rwClamped, h: rhClamped };
      updateZoomTransform();
      exitZoomMode();
      log('ã‚ºãƒ¼ãƒ ã‚’é©ç”¨ã—ã¾ã—ãŸï¼ˆéŒ²ç”»ãƒ»TLã‚‚ã“ã®ç¯„å›²ã‚’ä¿å­˜ï¼‰');
    }

    cameraWrapper.addEventListener('mousedown', (e) => {
      if (!zoomMode) return;
      e.preventDefault();
      const pos = getWrapperPosFromClient(e.clientX, e.clientY);
      zoomDragStart = pos;
      lastZoomPos = pos;
    }, { capture: true });
    cameraWrapper.addEventListener('mousemove', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      const pos = getWrapperPosFromClient(e.clientX, e.clientY);
      lastZoomPos = pos;
      drawZoomRectPreview(pos);
    }, { capture: true });
    cameraWrapper.addEventListener('mouseup', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      const pos = getWrapperPosFromClient(e.clientX, e.clientY);
      lastZoomPos = pos;
      finalizeZoom(pos);
    }, { capture: true });

    cameraWrapper.addEventListener('touchstart', (e) => {
      if (!zoomMode) return;
      e.preventDefault();
      const t = e.touches[0];
      const pos = getWrapperPosFromClient(t.clientX, t.clientY);
      zoomDragStart = pos;
      lastZoomPos = pos;
    }, { passive: false, capture: true });
    cameraWrapper.addEventListener('touchmove', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      const t = e.touches[0];
      const pos = getWrapperPosFromClient(t.clientX, t.clientY);
      lastZoomPos = pos;
      drawZoomRectPreview(pos);
    }, { passive: false, capture: true });
    cameraWrapper.addEventListener('touchend', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      finalizeZoom(null);
    }, { passive: false, capture: true });
  </script>
</body>
</html>
