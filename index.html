<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ã‚«ãƒ¡ãƒ©ï¼‹æ‰‹æãï¼‹ã‚ºãƒ¼ãƒ ï¼‹æ˜ åƒèª¿æ•´ï¼‹æ’®å½±</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont;
      background: #000;
      color: #fff;
    }
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    header {
      padding: 6px 10px;
      font-size: 13px;
      background: rgba(0,0,0,0.7);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 5;
      position: relative;
    }
    header span.title {
      font-weight: 600;
    }
    #header-right {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    #camera-wrapper {
      position: relative;
      flex: 1;
      background: #000;
      overflow: hidden;
      touch-action: none;
    }
    #camera-inner {
      position: absolute;
      inset: 0;
      transform-origin: 0 0;
    }
    #video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #draw-layer,
    #ui-layer {
      position: absolute;
      inset: 0;
    }
    #draw-layer {
      touch-action: none;
    }
    #ui-layer {
      pointer-events: none;
    }

    /* ä¸‹ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
    #toolbar {
      position: fixed;
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.65);
      backdrop-filter: blur(6px);
      z-index: 20;
      align-items: center;
    }
    .tool-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.04);
      color: #fff;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
    }
    .tool-btn.small {
      width: 28px;
      height: 28px;
      font-size: 14px;
    }
    .tool-btn:disabled {
      opacity: 0.3;
      cursor: default;
    }
    .tool-group-sep {
      width: 8px;
    }
    .rec-timer {
      font-size: 11px;
      min-width: 46px;
      text-align: center;
      color: #eee;
    }

    /* ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ‘ãƒãƒ«å…±é€š */
    .floating-panel {
      position: fixed;
      background: rgba(0,0,0,0.8);
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 11px;
      color: #eee;
      z-index: 25;
      max-width: 260px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
    }
    .floating-panel .panel-title {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 11px;
    }
    .floating-panel label {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 3px;
      white-space: nowrap;
    }
    .floating-panel input[type="number"] {
      width: 50px;
      font-size: 11px;
    }
    .floating-panel input[type="color"] {
      width: 32px;
      height: 18px;
      padding: 0;
      border: none;
      background: transparent;
    }
    .floating-panel input[type="range"] {
      width: 130px;
    }

    /* ãƒšãƒ³ãƒ‘ãƒãƒ«ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼å´ï¼‰ */
    #pen-panel {
      top: 36px;
      right: 10px;
      display: none;
    }

    /* æ˜ åƒè¨­å®šãƒ‘ãƒãƒ«ï¼ˆå³ä¸‹ï¼‰ */
    #video-panel {
      right: 10px;
      bottom: 60px;
      display: none;
    }

    /* ãƒ˜ãƒƒãƒ€å°ãƒœã‚¿ãƒ³ */
    #log-toggle,
    #pen-toggle,
    #btn-clear {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.06);
      color: #fff;
      width: 26px;
      height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 15px;
      padding: 0;
    }

    /* ãƒ­ã‚°ãƒ‘ãƒãƒ« */
    #log-panel {
      position: fixed;
      left: 10px;
      top: 40px;
      width: 240px;
      max-height: 50vh;
      background: rgba(0,0,0,0.8);
      border-radius: 8px;
      padding: 6px;
      font-size: 11px;
      color: #eee;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      z-index: 30;
      display: none;
    }
    #log-panel.open {
      display: block;
    }
    #log {
      max-height: 40vh;
      overflow-y: auto;
      white-space: pre-line;
    }

    /* ã‚ºãƒ¼ãƒ é¸æŠä¸­ã®æ¡ˆå†…ãƒ†ã‚­ã‚¹ãƒˆ */
    #zoom-hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: #fff;
      z-index: 25;
      display: none;
    }
    #zoom-hint.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <span class="title">ã‚«ãƒ¡ãƒ©ï¼‹æ‰‹æãï¼‹ã‚ºãƒ¼ãƒ ï¼‹æ˜ åƒèª¿æ•´ï¼‹é™æ­¢ç”»ï¼å‹•ç”»ï¼TL</span>
      <div id="header-right">
        <button id="pen-toggle" title="æ‰‹æãè¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º">âœï¸</button>
        <button id="btn-clear" title="æ‰‹æãã‚¯ãƒªã‚¢">ğŸ§¹</button>
        <button id="log-toggle" title="ãƒ­ã‚°è¡¨ç¤ºï¼éè¡¨ç¤º">â„¹ï¸</button>
      </div>
    </header>

    <div id="camera-wrapper">
      <div id="camera-inner">
        <video id="video" autoplay playsinline></video>
        <canvas id="draw-layer"></canvas>
        <canvas id="ui-layer"></canvas>
      </div>
    </div>

    <!-- ä¸‹ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
    <div id="toolbar">
      <!-- ã‚«ãƒ¡ãƒ© -->
      <button id="btn-start-camera" class="tool-btn" title="ã‚«ãƒ¡ãƒ©é–‹å§‹">ğŸ¦</button>

      <div class="tool-group-sep"></div>

      <!-- é™æ­¢ç”» -->
      <button id="btn-shot" class="tool-btn" title="å†™çœŸæ’®å½±ï¼ˆPNGï¼‰" disabled>ğŸ“·</button>

      <div class="tool-group-sep"></div>

      <!-- é€šå¸¸å‹•ç”» -->
      <button id="btn-start-rec" class="tool-btn small" title="å‹•ç”»éŒ²ç”»é–‹å§‹" disabled>âº</button>
      <button id="btn-stop-rec" class="tool-btn small" title="å‹•ç”»éŒ²ç”»åœæ­¢" disabled>â¹</button>
      <span id="rec-timer" class="rec-timer">00:00</span>

      <div class="tool-group-sep"></div>

      <!-- ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹ -->
      <button id="btn-start-tl" class="tool-btn small" title="TLéŒ²ç”»é–‹å§‹" disabled>â±</button>
      <button id="btn-stop-tl" class="tool-btn small" title="TLéŒ²ç”»åœæ­¢" disabled>â¹</button>
      <span id="tl-timer" class="rec-timer">00:00</span>

      <div class="tool-group-sep"></div>

      <!-- ã‚ºãƒ¼ãƒ  -->
      <button id="btn-zoom-select" class="tool-btn small" title="ã‚ºãƒ¼ãƒ é ˜åŸŸã‚’é¸æŠ">ğŸ”</button>
      <button id="btn-zoom-reset" class="tool-btn small" title="ã‚ºãƒ¼ãƒ è§£é™¤">ğŸ”</button>

      <div class="tool-group-sep" style="width:12px;"></div>

      <!-- æ˜ åƒè¨­å®šã‚¢ã‚¤ã‚³ãƒ³ -->
      <button id="video-settings-toggle" class="tool-btn small" title="æ˜ åƒè¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º">ğŸš</button>
    </div>

    <!-- æ‰‹æãè¨­å®šãƒ‘ãƒãƒ« -->
    <div id="pen-panel" class="floating-panel">
      <div class="panel-title">æ‰‹æãè¨­å®š</div>
      <label>è‰²
        <input type="color" id="pen-color" value="#ff0000">
      </label>
      <label>å¤ªã•
        <input type="number" id="pen-size" min="1" max="40" value="5">
      </label>
    </div>

    <!-- æ˜ åƒï¼‹éŒ²ç”»è¨­å®šãƒ‘ãƒãƒ« -->
    <div id="video-panel" class="floating-panel">
      <div class="panel-title">éŒ²ç”»ï¼ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹è¨­å®š</div>
      <label>å‹•ç”»FPS
        <input type="number" id="video-fps" min="1" max="60" value="30">
      </label>
      <label>TL-FPS
        <input type="number" id="tl-fps" min="1" max="60" value="10">
      </label>
      <label>TLé–“éš”(ms)
        <input type="number" id="tl-interval" min="100" value="500">
      </label>

      <div class="panel-title" style="margin-top:4px;">æ˜ åƒè¨­å®š</div>
      <label>æ˜ã‚‹ã•
        <input id="brightness" type="range" min="0.2" max="2" step="0.01" value="1">
      </label>
      <label>ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ
        <input id="contrast" type="range" min="0.5" max="2" step="0.01" value="1">
      </label>
      <label>éœ²å‡º
        <input id="exposure" type="range" min="-2" max="2" step="0.1" value="0">
      </label>
      <label>è‰²æ¸©åº¦
        <input id="color-temp" type="range" min="-1" max="1" step="0.1" value="0">
      </label>
      <label>ã‚·ãƒ£ãƒ¼ãƒ—
        <input id="sharpness" type="range" min="0" max="1" step="0.1" value="0">
      </label>
      <label>
        <input id="ai-fix" type="checkbox">
        AIè£œæ­£(ç°¡æ˜“)
      </label>

      <div class="panel-title" style="margin-top:4px;">è¡¨ç¤ºåè»¢</div>
      <label>
        <input id="flip-h" type="checkbox" checked>
        å·¦å³åè»¢ï¼ˆãƒŸãƒ©ãƒ¼ï¼‰
      </label>
      <label>
        <input id="flip-v" type="checkbox">
        ä¸Šä¸‹åè»¢
      </label>
      <div style="margin-top:3px;color:#ccc;">
        â€»ãƒ–ãƒ©ã‚¦ã‚¶éŒ²ç”»ã¯ WebM å½¢å¼ã«ãªã‚Šã¾ã™ã€‚mp4/mov ãŒå¿…è¦ãªå ´åˆã¯å¤–éƒ¨ãƒ„ãƒ¼ãƒ«ã§å¤‰æ›ã—ã¦ãã ã•ã„ã€‚
      </div>
    </div>

    <!-- ãƒ­ã‚°ãƒ‘ãƒãƒ« -->
    <div id="log-panel">
      <div style="font-weight:600;margin-bottom:4px;">ãƒ­ã‚°</div>
      <div id="log"></div>
      <div style="margin-top:4px;color:#ccc;">
        â€»ã‚ºãƒ¼ãƒ æ™‚ã¯ã€éŒ²ç”»ãƒ»TLã‚‚ã‚ºãƒ¼ãƒ ç¯„å›²ã‚’æ¯”ç‡ç¶­æŒã§åˆ‡ã‚Šå‡ºã—ã€ä½™ç™½ã¯é»’ã«ãªã‚Šã¾ã™ã€‚<br>
        â€»ã‚·ãƒ£ãƒ¼ãƒ—ãƒã‚¹ï¼AIè£œæ­£ã¯é‡ã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚
      </div>
    </div>

    <!-- ã‚ºãƒ¼ãƒ é¸æŠä¸­ã®ãƒ’ãƒ³ãƒˆ -->
    <div id="zoom-hint">ã‚ºãƒ¼ãƒ ã—ãŸã„ç¯„å›²ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆæŒ‡ï¼ãƒšãƒ³ï¼ãƒã‚¦ã‚¹ï¼‰</div>
  </div>

  <script>
    const video = document.getElementById('video');
    const drawCanvas = document.getElementById('draw-layer');
    const drawCtx = drawCanvas.getContext('2d');
    const uiCanvas = document.getElementById('ui-layer');
    const uiCtx = uiCanvas.getContext('2d');
    const cameraWrapper = document.getElementById('camera-wrapper');
    const cameraInner = document.getElementById('camera-inner');

    const btnStartCamera = document.getElementById('btn-start-camera');
    const btnClear = document.getElementById('btn-clear');
    const btnShot = document.getElementById('btn-shot');
    const btnStartRec = document.getElementById('btn-start-rec');
    const btnStopRec = document.getElementById('btn-stop-rec');
    const btnStartTl = document.getElementById('btn-start-tl');
    const btnStopTl = document.getElementById('btn-stop-tl');
    const btnZoomSelect = document.getElementById('btn-zoom-select');
    const btnZoomReset = document.getElementById('btn-zoom-reset');
    const videoSettingsToggle = document.getElementById('video-settings-toggle');

    const penToggle = document.getElementById('pen-toggle');
    const penPanel = document.getElementById('pen-panel');
    const videoPanel = document.getElementById('video-panel');

    const penColorInput = document.getElementById('pen-color');
    const penSizeInput = document.getElementById('pen-size');
    const videoFpsInput = document.getElementById('video-fps');
    const tlFpsInput = document.getElementById('tl-fps');
    const tlIntervalInput = document.getElementById('tl-interval');

    const brightnessSlider = document.getElementById('brightness');
    const contrastSlider = document.getElementById('contrast');
    const exposureSlider = document.getElementById('exposure');
    const colorTempSlider = document.getElementById('color-temp');
    const sharpnessSlider = document.getElementById('sharpness');
    const aiFixCheckbox = document.getElementById('ai-fix');
    const flipHCheckbox = document.getElementById('flip-h');
    const flipVCheckbox = document.getElementById('flip-v');

    const logEl = document.getElementById('log');
    const logPanel = document.getElementById('log-panel');
    const logToggle = document.getElementById('log-toggle');
    const zoomHint = document.getElementById('zoom-hint');

    const recTimerEl = document.getElementById('rec-timer');
    const tlTimerEl = document.getElementById('tl-timer');

    let cameraStream = null;

    // åˆæˆç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹
    const compositeCanvas = document.createElement('canvas');
    const compositeCtx = compositeCanvas.getContext('2d');

    // ã‚¢ãƒ³ãƒã‚¨ã‚¤ãƒªã‚¢ã‚¹æŠ‘åˆ¶ï¼ˆå°‘ã—ã‚·ãƒ£ãƒ¼ãƒ—ã«ï¼‰
    drawCtx.imageSmoothingEnabled = false;
    uiCtx.imageSmoothingEnabled = false;
    compositeCtx.imageSmoothingEnabled = false;

    // æ‰‹æãçŠ¶æ…‹
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    // éŒ²ç”»é–¢é€£
    let recorder = null;
    let recordedChunks = [];
    let recordingMode = null; // "normal" or "timelapse"
    let animationId = null;
    let lastTlTime = 0;
    let tlIntervalMs = 500;

    // ã‚¿ã‚¤ãƒãƒ¼
    let recStartTime = null;
    let tlStartTime = null;
    let recTimerId = null;
    let tlTimerId = null;

    // ã‚ºãƒ¼ãƒ é–¢é€£
    let zoomMode = false;
    let zoomRect = null;         // {x,y,w,h} in wrapper CSS coords
    let zoomDragStart = null;    // {x,y}
    let lastZoomPos = null;      // {x,y}

    // æ˜ åƒè¨­å®š
    const settings = {
      brightness: 1,
      contrast: 1,
      exposure: 0,
      colorTemp: 0,
      sharpness: 0,
      aiFix: false
    };
    let videoFilterString = 'brightness(1) contrast(1)';
    let flipH = true;
    let flipV = false;

    function log(msg) {
      const now = new Date();
      const time = now.toLocaleTimeString();
      logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
    }

    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const m = Math.floor(totalSec / 60);
      const s = totalSec % 60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function startRecTimer() {
      recStartTime = Date.now();
      recTimerEl.textContent = '00:00';
      if (recTimerId) clearInterval(recTimerId);
      recTimerId = setInterval(() => {
        recTimerEl.textContent = formatTime(Date.now() - recStartTime);
      }, 500);
    }
    function stopRecTimer() {
      if (recTimerId) {
        clearInterval(recTimerId);
        recTimerId = null;
      }
    }
    function startTlTimer() {
      tlStartTime = Date.now();
      tlTimerEl.textContent = '00:00';
      if (tlTimerId) clearInterval(tlTimerId);
      tlTimerId = setInterval(() => {
        tlTimerEl.textContent = formatTime(Date.now() - tlStartTime);
      }, 500);
    }
    function stopTlTimer() {
      if (tlTimerId) {
        clearInterval(tlTimerId);
        tlTimerId = null;
      }
    }

    // ãƒ­ã‚°ãƒ»ãƒ‘ãƒãƒ«åˆ‡æ›¿
    logToggle.addEventListener('click', () => {
      logPanel.classList.toggle('open');
    });
    penToggle.addEventListener('click', () => {
      penPanel.style.display = penPanel.style.display === 'block' ? 'none' : 'block';
    });
    videoSettingsToggle.addEventListener('click', () => {
      videoPanel.style.display = videoPanel.style.display === 'block' ? 'none' : 'block';
    });

    // ã‚«ãƒ¡ãƒ©é–‹å§‹
    btnStartCamera.addEventListener('click', async () => {
      try {
        cameraStream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1920 }, height: { ideal: 1080 } },
          audio: true
        });
        video.srcObject = cameraStream;
        log('ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¾ã—ãŸ');

        video.addEventListener('loadedmetadata', () => {
          resizeCanvases();
          btnShot.disabled = false;
          btnStartRec.disabled = false;
          btnStartTl.disabled = false;
        }, { once: true });

        btnStartCamera.disabled = true;
      } catch (e) {
        console.error(e);
        log('ã‚«ãƒ¡ãƒ©ãŒè¨±å¯ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ');
      }
    });

    // é«˜è§£åƒåº¦ã‚­ãƒ£ãƒ³ãƒã‚¹
    function resizeCanvases() {
      const rect = cameraWrapper.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      const dpr = window.devicePixelRatio || 1;

      [drawCanvas, uiCanvas, compositeCanvas].forEach(c => {
        c.width = width * dpr;
        c.height = height * dpr;
        c.style.width = width + 'px';
        c.style.height = height + 'px';
      });

      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);

      zoomRect = null;
      updateZoomTransform();

      log(`ã‚­ãƒ£ãƒ³ãƒã‚¹: ${width}x${height} (DPR=${dpr} â†’ å†…éƒ¨ ${drawCanvas.width}x${drawCanvas.height})`);
    }

    window.addEventListener('resize', () => {
      if (video.videoWidth) resizeCanvases();
    });

    // ===== æ‰‹æã =====
    function getCanvasPos(e) {
      const rect = drawCanvas.getBoundingClientRect();
      let clientX, clientY;
      if (e.touches && e.touches[0]) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      const x = (clientX - rect.left) * (drawCanvas.width / rect.width);
      const y = (clientY - rect.top) * (drawCanvas.height / rect.height);
      return { x, y };
    }

    function startDraw(e) {
      if (zoomMode) return;
      e.preventDefault();
      isDrawing = true;
      const pos = getCanvasPos(e);
      lastX = pos.x;
      lastY = pos.y;
    }

    function draw(e) {
      if (!isDrawing || zoomMode) return;
      e.preventDefault();
      const pos = getCanvasPos(e);
      drawCtx.strokeStyle = penColorInput.value;
      drawCtx.lineWidth = Number(penSizeInput.value) || 3;
      drawCtx.lineCap = 'round';
      drawCtx.lineJoin = 'round';

      drawCtx.beginPath();
      drawCtx.moveTo(lastX, lastY);
      drawCtx.lineTo(pos.x, pos.y);
      drawCtx.stroke();

      lastX = pos.x;
      lastY = pos.y;
    }

    function endDraw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false;
    }

    drawCanvas.addEventListener('mousedown', startDraw);
    drawCanvas.addEventListener('mousemove', draw);
    drawCanvas.addEventListener('mouseup', endDraw);
    drawCanvas.addEventListener('mouseleave', endDraw);

    drawCanvas.addEventListener('touchstart', startDraw, { passive: false });
    drawCanvas.addEventListener('touchmove', draw, { passive: false });
    drawCanvas.addEventListener('touchend', endDraw, { passive: false });
    drawCanvas.addEventListener('touchcancel', endDraw, { passive: false });

    btnClear.addEventListener('click', () => {
      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      log('æ‰‹æããƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
    });

    // ===== ãƒ•ã‚£ãƒ«ã‚¿ãƒ»åè»¢ =====
    function updateVideoFilter() {
      const exposureFactor = Math.pow(2, settings.exposure);
      const b = settings.brightness * exposureFactor;
      const c = settings.contrast;
      const t = settings.colorTemp;

      let filter = `brightness(${b}) contrast(${c})`;
      if (t > 0) {
        const amt = t;
        filter += ` sepia(${amt}) saturate(${1 + 0.5 * amt}) hue-rotate(-10deg)`;
      } else if (t < 0) {
        const amt = -t;
        filter += ` saturate(${1 - 0.3 * amt}) hue-rotate(${amt * 20}deg)`;
      }
      videoFilterString = filter;
      video.style.filter = filter;
    }

    function updateVideoFlipPreview() {
      const sx = flipH ? -1 : 1;
      const sy = flipV ? -1 : 1;
      video.style.transform = `scaleX(${sx}) scaleY(${sy})`;
    }

    brightnessSlider.addEventListener('input', () => {
      settings.brightness = parseFloat(brightnessSlider.value) || 1;
      updateVideoFilter();
    });
    contrastSlider.addEventListener('input', () => {
      settings.contrast = parseFloat(contrastSlider.value) || 1;
      updateVideoFilter();
    });
    exposureSlider.addEventListener('input', () => {
      settings.exposure = parseFloat(exposureSlider.value) || 0;
      updateVideoFilter();
    });
    colorTempSlider.addEventListener('input', () => {
      settings.colorTemp = parseFloat(colorTempSlider.value) || 0;
      updateVideoFilter();
    });
    sharpnessSlider.addEventListener('input', () => {
      settings.sharpness = parseFloat(sharpnessSlider.value) || 0;
    });
    aiFixCheckbox.addEventListener('change', () => {
      settings.aiFix = aiFixCheckbox.checked;
      log(`AIè£œæ­£(ç°¡æ˜“): ${settings.aiFix ? 'ON' : 'OFF'}`);
    });
    flipHCheckbox.addEventListener('change', () => {
      flipH = flipHCheckbox.checked;
      updateVideoFlipPreview();
      log(`å·¦å³åè»¢: ${flipH ? 'ON' : 'OFF'}`);
    });
    flipVCheckbox.addEventListener('change', () => {
      flipV = flipVCheckbox.checked;
      updateVideoFlipPreview();
      log(`ä¸Šä¸‹åè»¢: ${flipV ? 'ON' : 'OFF'}`);
    });

    updateVideoFilter();
    updateVideoFlipPreview();

    // ===== ã‚·ãƒ£ãƒ¼ãƒ—ãƒã‚¹ =====
    function applySharpen(amount) {
      if (amount <= 0) return;
      const w = compositeCanvas.width;
      const h = compositeCanvas.height;
      if (!w || !h) return;

      const img = compositeCtx.getImageData(0, 0, w, h);
      const data = img.data;
      const src = new Uint8ClampedArray(data);

      const center = 5 + 4 * amount;
      const kernel = [
        0, -1, 0,
        -1, center, -1,
        0, -1, 0
      ];

      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const idx = (y * w + x) * 4;
          let r = 0, g = 0, b = 0;
          let ki = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx2 = ((y + ky) * w + (x + kx)) * 4;
              const wgt = kernel[ki++];
              r += src[idx2] * wgt;
              g += src[idx2 + 1] * wgt;
              b += src[idx2 + 2] * wgt;
            }
          }
          data[idx]     = Math.max(0, Math.min(255, r));
          data[idx + 1] = Math.max(0, Math.min(255, g));
          data[idx + 2] = Math.max(0, Math.min(255, b));
        }
      }
      compositeCtx.putImageData(img, 0, 0);
    }

    // ===== åˆæˆ =====
    function drawCompositeFrame() {
      const w = compositeCanvas.width;
      const h = compositeCanvas.height;
      if (!w || !h) return;
      if (!video.videoWidth || !video.videoHeight) return;

      compositeCtx.fillStyle = 'black';
      compositeCtx.fillRect(0, 0, w, h);

      const Wcss = cameraWrapper.clientWidth;
      const Hcss = cameraWrapper.clientHeight;
      const dpr = window.devicePixelRatio || 1;

      if (zoomRect) {
        const vw = video.videoWidth;
        const vh = video.videoHeight;
        const s = Math.max(Wcss / vw, Hcss / vh);
        const vsW = vw * s;
        const vsH = vh * s;
        const dx = (Wcss - vsW) / 2;
        const dy = (Hcss - vsH) / 2;

        let sx = (zoomRect.x - dx) / s;
        let sy = (zoomRect.y - dy) / s;
        let sw = zoomRect.w / s;
        let sh = zoomRect.h / s;

        let sx2 = Math.max(0, sx);
        let sy2 = Math.max(0, sy);
        let ex = Math.min(vw, sx + sw);
        let ey = Math.min(vh, sy + sh);
        sw = ex - sx2;
        sh = ey - sy2;
        if (sw <= 0 || sh <= 0) return;

        const srcAspect = sw / sh;
        const dstAspect = w / h;
        let destW, destH, destX, destY;
        if (srcAspect > dstAspect) {
          destW = w;
          destH = w / srcAspect;
          destX = 0;
          destY = (h - destH) / 2;
        } else {
          destH = h;
          destW = h * srcAspect;
          destY = 0;
          destX = (w - destW) / 2;
        }

        // æ˜ åƒï¼‹åè»¢ï¼‹ãƒ•ã‚£ãƒ«ã‚¿
        compositeCtx.save();
        compositeCtx.filter = videoFilterString || 'none';
        compositeCtx.translate(destX + destW / 2, destY + destH / 2);
        compositeCtx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
        compositeCtx.drawImage(
          video,
          sx2, sy2, sw, sh,
          -destW / 2, -destH / 2, destW, destH
        );
        compositeCtx.restore();

        // æ‰‹æãï¼ˆã‚ºãƒ¼ãƒ ç¯„å›²åˆ†ã ã‘ï¼‰
        compositeCtx.drawImage(
          drawCanvas,
          zoomRect.x * dpr,
          zoomRect.y * dpr,
          zoomRect.w * dpr,
          zoomRect.h * dpr,
          destX, destY, destW, destH
        );
      } else {
        compositeCtx.save();
        compositeCtx.filter = videoFilterString || 'none';
        compositeCtx.translate(w / 2, h / 2);
        compositeCtx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
        compositeCtx.drawImage(video, -w / 2, -h / 2, w, h);
        compositeCtx.restore();

        compositeCtx.drawImage(drawCanvas, 0, 0, w, h);
      }

      const baseSharp = settings.sharpness;
      const extra = settings.aiFix ? 0.4 : 0;
      const amount = Math.min(1, Math.max(0, baseSharp + extra));
      if (amount > 0) applySharpen(amount);
    }

    // ===== é™æ­¢ç”» =====
    btnShot.addEventListener('click', () => {
      drawCompositeFrame();
      const url = compositeCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.href = url;
      a.download = `snapshot_${ts}.png`;
      a.click();
      log('é™æ­¢ç”»ã‚’PNGã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸï¼ˆæ˜ åƒè¨­å®šãƒ»åè»¢ãƒ»ã‚ºãƒ¼ãƒ åæ˜ ï¼‰');
    });

    // ===== é€šå¸¸éŒ²ç”» =====
    btnStartRec.addEventListener('click', () => {
      if (!cameraStream) {
        log('å…ˆã«ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¦ãã ã•ã„');
        return;
      }
      const fps = Number(videoFpsInput.value) || 30;

      const stream = compositeCanvas.captureStream(fps);
      const audioTracks = cameraStream.getAudioTracks();
      audioTracks.forEach(t => stream.addTrack(t));

      recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      recordedChunks = [];
      recordingMode = 'normal';

      recorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      recorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `record_normal_${ts}.webm`;
        a.click();
        log('é€šå¸¸å‹•ç”»(WebM)ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
      };

      const render = () => {
        drawCompositeFrame();
        animationId = requestAnimationFrame(render);
      };
      render();

      recorder.start();
      btnStartRec.disabled = true;
      btnStopRec.disabled = false;
      btnStartTl.disabled = true;
      startRecTimer();
      log(`é€šå¸¸éŒ²ç”»é–‹å§‹ (FPS: ${fps}, ã‚ºãƒ¼ãƒ : ${zoomRect ? 'ON' : 'OFF'})`);
    });

    btnStopRec.addEventListener('click', () => {
      if (!recorder || recordingMode !== 'normal') return;
      recorder.stop();
      cancelAnimationFrame(animationId);
      animationId = null;
      btnStartRec.disabled = false;
      btnStopRec.disabled = true;
      btnStartTl.disabled = false;
      stopRecTimer();
      log('é€šå¸¸éŒ²ç”»åœæ­¢');
    });

    // ===== ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹ =====
    btnStartTl.addEventListener('click', () => {
      if (!cameraStream) {
        log('å…ˆã«ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¦ãã ã•ã„');
        return;
      }
      const fps = Number(tlFpsInput.value) || 10;
      tlIntervalMs = Number(tlIntervalInput.value) || 500;

      const stream = compositeCanvas.captureStream(fps);
      recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      recordedChunks = [];
      recordingMode = 'timelapse';
      lastTlTime = performance.now();

      recorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      recorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `record_timelapse_${ts}.webm`;
        a.click();
        log('ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹å‹•ç”»(WebM)ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
      };

      const renderTl = (time) => {
        if (time - lastTlTime >= tlIntervalMs) {
          drawCompositeFrame();
          lastTlTime = time;
        }
        animationId = requestAnimationFrame(renderTl);
      };
      animationId = requestAnimationFrame(renderTl);

      recorder.start();
      btnStartTl.disabled = true;
      btnStopTl.disabled = false;
      btnStartRec.disabled = true;
      startTlTimer();
      log(`ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹éŒ²ç”»é–‹å§‹ (éŒ²ç”»FPS: ${fps}, é–“éš”: ${tlIntervalMs}ms, ã‚ºãƒ¼ãƒ : ${zoomRect ? 'ON' : 'OFF'})`);
    });

    btnStopTl.addEventListener('click', () => {
      if (!recorder || recordingMode !== 'timelapse') return;
      recorder.stop();
      cancelAnimationFrame(animationId);
      animationId = null;
      btnStartTl.disabled = false;
      btnStopTl.disabled = true;
      btnStartRec.disabled = false;
      stopTlTimer();
      log('ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹éŒ²ç”»åœæ­¢');
    });

    // ===== ã‚ºãƒ¼ãƒ æ©Ÿèƒ½ =====
    function updateZoomTransform() {
      if (!zoomRect) {
        cameraInner.style.transform = 'translate(0px, 0px) scale(1)';
        return;
      }
      const W = cameraWrapper.clientWidth;
      const H = cameraWrapper.clientHeight;
      if (!W || !H) return;

      const r = zoomRect;
      const s = Math.max(W / r.w, H / r.h);

      const cx = r.x + r.w / 2;
      const cy = r.y + r.h / 2;
      const CwX = W / 2;
      const CwY = H / 2;

      const tx = CwX - s * cx;
      const ty = CwY - s * cy;

      cameraInner.style.transform = `translate(${tx}px, ${ty}px) scale(${s})`;
    }

    function getWrapperPosFromClient(clientX, clientY) {
      const rect = cameraWrapper.getBoundingClientRect();
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    function clearUiCanvas() {
      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
    }

    function enterZoomMode() {
      zoomMode = true;
      zoomDragStart = null;
      lastZoomPos = null;
      clearUiCanvas();
      zoomHint.classList.add('visible');
      // ã‚ºãƒ¼ãƒ ä¸­ã¯ drawCanvas ã‚’ã‚¯ãƒªãƒƒã‚¯ã§ããªã„ã‚ˆã†ã« â†’ wrapper ã§çŸ©å½¢ã‚’å–ã‚‹
      drawCanvas.style.pointerEvents = 'none';
      log('ã‚ºãƒ¼ãƒ é ˜åŸŸé¸æŠãƒ¢ãƒ¼ãƒ‰ï¼šæ˜ åƒä¸Šã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãã ã•ã„');
    }

    function exitZoomMode() {
      zoomMode = false;
      zoomDragStart = null;
      lastZoomPos = null;
      clearUiCanvas();
      zoomHint.classList.remove('visible');
      drawCanvas.style.pointerEvents = 'auto';
    }

    btnZoomSelect.addEventListener('click', () => {
      if (!video.videoWidth) {
        log('ã‚«ãƒ¡ãƒ©èµ·å‹•å¾Œã«ã‚ºãƒ¼ãƒ ã§ãã¾ã™');
        return;
      }
      enterZoomMode();
    });

    btnZoomReset.addEventListener('click', () => {
      zoomRect = null;
      updateZoomTransform();
      exitZoomMode();
      log('ã‚ºãƒ¼ãƒ ã‚’è§£é™¤ã—ã¾ã—ãŸ');
    });

    function drawZoomRectPreview(currentPos) {
      const start = zoomDragStart;
      clearUiCanvas();
      uiCtx.strokeStyle = '#00ff88';
      uiCtx.lineWidth = 2;
      uiCtx.setLineDash([6, 4]);

      const rect = cameraWrapper.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const scaleX = uiCanvas.width / rect.width;
      const scaleY = uiCanvas.height / rect.height;

      const x = Math.min(start.x, currentPos.x) * scaleX;
      const y = Math.min(start.y, currentPos.y) * scaleY;
      const w = Math.abs(currentPos.x - start.x) * scaleX;
      const h = Math.abs(currentPos.y - start.y) * scaleY;

      uiCtx.strokeRect(x, y, w, h);
      uiCtx.setLineDash([]);
    }

    function finalizeZoom(endPosMaybe) {
      const endPos = endPosMaybe || lastZoomPos || zoomDragStart;
      if (!zoomDragStart || !endPos) {
        exitZoomMode();
        log('ã‚ºãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ');
        return;
      }

      const x0 = zoomDragStart.x;
      const y0 = zoomDragStart.y;
      const x1 = endPos.x;
      const y1 = endPos.y;
      const rx = Math.min(x0, x1);
      const ry = Math.min(y0, y1);
      const rw = Math.abs(x1 - x0);
      const rh = Math.abs(y1 - y0);

      const minSize = 20;
      if (rw < minSize || rh < minSize) {
        exitZoomMode();
        log('é¸æŠç¯„å›²ãŒå°ã•ã™ãã‚‹ãŸã‚ã‚ºãƒ¼ãƒ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ');
        return;
      }

      const W = cameraWrapper.clientWidth;
      const H = cameraWrapper.clientHeight;
      const rxClamped = Math.max(0, Math.min(rx, W));
      const ryClamped = Math.max(0, Math.min(ry, H));
      const rwClamped = Math.min(rw, W - rxClamped);
      const rhClamped = Math.min(rh, H - ryClamped);

      zoomRect = { x: rxClamped, y: ryClamped, w: rwClamped, h: rhClamped };
      updateZoomTransform();
      exitZoomMode();
      log('ã‚ºãƒ¼ãƒ ã‚’é©ç”¨ã—ã¾ã—ãŸï¼ˆéŒ²ç”»ãƒ»TLã‚‚ã“ã®ç¯„å›²ã‚’æ¯”ç‡ç¶­æŒã§ä¿å­˜ï¼‰');
    }

    // ãƒã‚¦ã‚¹ã§ã®ã‚ºãƒ¼ãƒ 
    cameraWrapper.addEventListener('mousedown', (e) => {
      if (!zoomMode) return;
      e.preventDefault();
      const pos = getWrapperPosFromClient(e.clientX, e.clientY);
      zoomDragStart = pos;
      lastZoomPos = pos;
    });
    cameraWrapper.addEventListener('mousemove', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      const pos = getWrapperPosFromClient(e.clientX, e.clientY);
      lastZoomPos = pos;
      drawZoomRectPreview(pos);
    });
    cameraWrapper.addEventListener('mouseup', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      const pos = getWrapperPosFromClient(e.clientX, e.clientY);
      lastZoomPos = pos;
      finalizeZoom(pos);
    });

    // ã‚¿ãƒƒãƒã§ã®ã‚ºãƒ¼ãƒ ï¼ˆiPadãªã©ï¼‰
    cameraWrapper.addEventListener('touchstart', (e) => {
      if (!zoomMode) return;
      e.preventDefault();
      const t = e.touches[0];
      const pos = getWrapperPosFromClient(t.clientX, t.clientY);
      zoomDragStart = pos;
      lastZoomPos = pos;
    }, { passive: false });
    cameraWrapper.addEventListener('touchmove', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      const t = e.touches[0];
      const pos = getWrapperPosFromClient(t.clientX, t.clientY);
      lastZoomPos = pos;
      drawZoomRectPreview(pos);
    }, { passive: false });
    cameraWrapper.addEventListener('touchend', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      finalizeZoom(null); // lastZoomPos ã‚’ä½¿ã†
    }, { passive: false });

    cameraWrapper.addEventListener('mouseleave', () => {
      if (!zoomMode) return;
      exitZoomMode();
    });
  </script>
</body>
</html>
